//! Encoder entropy point.

use crate::common::data_structures::AVCCFormat;
use crate::common::data_structures::H264DecodedStream;
use crate::common::data_structures::PicParameterSet;
use crate::common::data_structures::SeqParameterSet;
use crate::common::data_structures::SubsetSPS;
use crate::common::data_structures::VideoParameters;
use crate::encoder::nalu::encode_access_unit_delimiter;
use crate::encoder::nalu::encode_nalu_header;
use crate::encoder::nalu::encode_prefix_nal_unit_svc;
use crate::encoder::parameter_sets::encode_pps;
use crate::encoder::parameter_sets::encode_sps;
use crate::encoder::parameter_sets::encode_sps_extension;
use crate::encoder::parameter_sets::encode_subset_sps;
use crate::encoder::sei::encode_sei_message;
use crate::encoder::slice::encode_slice;
use crate::encoder::slice::encode_slice_layer_extension_rbsp;
use hex;
use log::debug;
use minimp4::Mp4Muxer; // COMMENT OUT IF WANT TO USE WITH AFL++ Binding
use std::fs::File;
use std::io::prelude::*;

/// Insert the emulation three byte to an encoded stream
pub fn insert_emulation_three_byte(stream: &[u8]) -> Vec<u8> {
    let mut res: Vec<u8> = Vec::new();

    //let mut epb_count = 0;
    //let mut count = 0;
    //let mut offset_overwrite = 0;

    let mut zero1 = false;
    let mut zero2 = false;
    for &cur_byte in stream {
        //count += 1;
        if zero1 {
            if zero2 {
                if cur_byte == 0 || cur_byte == 1 || cur_byte == 2 || cur_byte == 3 {
                    //epb_count+=1;

                    /*
                    // This snippet is used for targeting with CVE-2022-32939
                    if epb_count == 257 {
                        offset_overwrite = count*8 + 1;
                        // The location of the 257th emulation prevention byte overwrites
                        // the array index. This value is subsequently incremented.
                        println!("[X] Index Overwrite:  0x{:x}", offset_overwrite);
                        debug!(target: "encode","[X] Index Overwrite: 0x{:x}", offset_overwrite);
                    } else if epb_count == 258 {
                        // The location of the 258th emulation prevention byte is
                        // used to calculate the value we write
                        let value_to_write = 8*(count-offset_overwrite+1) + 2048;
                        println!("[X] Write value: {} (0x{:x})", value_to_write, value_to_write);
                        debug!(target: "encode","[X] Write value: {} (0x{:x})", value_to_write, value_to_write);
                    }
                    */
                    res.push(3); // insert emulation 3 byte
                }
                zero1 = false;
                zero2 = false;
            } else if cur_byte == 0 {
                zero2 = true;
            } else {
                zero1 = false;
            }
        }
        // we get rid of the else because of the following case: 0x00 0x00 0x00 0x00 0x00 0x00
        // it should be set to 0x00 0x00 0x03 0x00 0x00 0x03 0x00 0x00
        if cur_byte == 0 {
            zero1 = true;
        }

        res.push(cur_byte);
    }

    //println!("[X] Added {} emulation prevention bytes", epb_count);

    res
}

/// Creates the AVCC header which contains version bits, and all SPSes & PPSes
/// Reference: https://stackoverflow.com/a/24890903/8169613
fn encode_avcc_extradata(avcc_encoding: &AVCCFormat) -> Vec<u8> {
    /*
        bits
        8   version ( always 0x01 )
        8   avc profile ( sps[0][1] )
        8   avc compatibility ( sps[0][2] )
        8   avc level ( sps[0][3] )
        6   reserved ( all bits on )
        2   NALULengthSizeMinusOne (this is how many bytes to use for the length element of a NALU)
        3   reserved ( all bits on )
        5   number of SPS NALUs (usually 1)

        repeated once per SPS:
        16         SPS size
        variable   SPS NALU data

        8   number of PPS NALUs (usually 1)

        repeated once per PPS:
        16       PPS size
        variable PPS NALU data
    */

    let mut avcc_extradata: Vec<u8> = vec![1, avcc_encoding.initial_sps.profile_idc]; // version and avc profile

    // collect the constraint_set flags
    let compatibility = ((match avcc_encoding.initial_sps.constraint_set0_flag {
        true => 1,
        false => 0,
    }) << 7)
        | ((match avcc_encoding.initial_sps.constraint_set1_flag {
            true => 1,
            false => 0,
        }) << 6)
        | ((match avcc_encoding.initial_sps.constraint_set2_flag {
            true => 1,
            false => 0,
        }) << 5)
        | ((match avcc_encoding.initial_sps.constraint_set3_flag {
            true => 1,
            false => 0,
        }) << 4)
        | ((match avcc_encoding.initial_sps.constraint_set4_flag {
            true => 1,
            false => 0,
        }) << 3)
        | ((match avcc_encoding.initial_sps.constraint_set5_flag {
            true => 1,
            false => 0,
        }) << 2);
    avcc_extradata.push(compatibility); // compatibility
    avcc_extradata.push(avcc_encoding.initial_sps.level_idc); // avc level

    avcc_extradata.push(0xff); // 6 bits are on; the last two bits are how many length bytes there are before each NALU (in our case, we'll use 4)

    // number of SPSes
    if avcc_encoding.sps_list.len() > 31 {
        println!(
            "[WARNING] AVCC can only support at most 5 bits worth of SPSes, there may be an error"
        );
    }
    avcc_extradata.push(0xe0 | (0x1F & (avcc_encoding.sps_list.len() as u8))); // the top 3 reserved bits + 5 bits of length

    // for each SPS, 16 bits of SPS size and the amount of bytes
    for s in &avcc_encoding.sps_list {
        if s.len() > 0xffff {
            println!("[WARNING] AVCC can only support 65,536 bytes of SPS; There will be an issue parsing")
        }

        let first_byte = (s.len() & 0xff00) >> 8;
        let second_byte = s.len() & 0xff;

        avcc_extradata.push(first_byte as u8);
        avcc_extradata.push(second_byte as u8);

        avcc_extradata.extend(s);
    }

    // number of PPSes
    if avcc_encoding.pps_list.len() > 255 {
        println!(
            "[WARNING] AVCC can only support at most 8 bits worth of PPSes, there may be an error"
        );
    }
    avcc_extradata.push(avcc_encoding.pps_list.len() as u8);

    // for each PPS, 16 bits of PPS size and then the bytes
    for p in &avcc_encoding.pps_list {
        if p.len() > 0xffff {
            println!("[WARNING] AVCC can only support 65,536 bytes of PPS; There will be an issue parsing")
        }

        let first_byte = (p.len() & 0xff00) >> 8;
        let second_byte = p.len() & 0xff;

        avcc_extradata.push(first_byte as u8);
        avcc_extradata.push(second_byte as u8);

        avcc_extradata.extend(p);
    }

    avcc_extradata
}

/// Encoded Slice data into AVCC format, which is prepended by its length, rather than a start code
fn encode_avcc_data(slice_list: Vec<Vec<u8>>) -> Vec<u8> {
    let mut encoded: Vec<u8> = Vec::new();

    for sl in slice_list {
        // we use the default of 4 bytes to indicate NALU length
        let first_byte = (sl.len() & 0xff000000) >> 24;
        let second_byte = (sl.len() & 0x00ff0000) >> 16;
        let third_byte = (sl.len() & 0x0000ff00) >> 8;
        let fourth_byte = sl.len() & 0x000000ff;

        encoded.push(first_byte as u8);
        encoded.push(second_byte as u8);
        encoded.push(third_byte as u8);
        encoded.push(fourth_byte as u8);

        encoded.extend(sl);
    }

    encoded
}

/*
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣶⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⠿⠟⠛⠻⣿⠆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣆⣀⣀⠀⣿⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠻⣿⣿⣿⠅⠛⠋⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⢼⣿⣿⣿⣃⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣟⡿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣛⣛⣫⡄⠀⢸⣦⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣠⣴⣾⡆⠸⣿⣿⣿⡷⠂⠨⣿⣿⣿⣿⣶⣦⣤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣤⣾⣿⣿⣿⣿⡇⢀⣿⡿⠋⠁⢀⡶⠪⣉⢸⣿⣿⣿⣿⣿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣿⣿⣿⣿⣿⣿⣿⣿⡏⢸⣿⣷⣿⣿⣷⣦⡙⣿⣿⣿⣿⣿⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⣿⣿⣿⣿⣿⣇⢸⣿⣿⣿⣿⣿⣷⣦⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⡿⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀
⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣵⣾⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣿⣯⡁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
*/
const SAFESTART_VIDEO_HEIGHT: i32 = 240;
const SAFESTART_VIDEO_WIDTH: i32 = 426;
const SAFESTART_VIDEO: [u8; 6272] = [
    0x00, 0x00, 0x00, 0x01, 0x67, 0x64, 0x00, 0x15, 0xAC, 0xD9, 0x41, 0xB1, 0xFE, 0x4F, 0x01,
    0x6C, // SPS
    0x80, 0x00, 0x00, 0x03, 0x00, 0x80, 0x00, 0x00, 0x05, 0x07, 0x8B, 0x16, 0xCB, 0x00, 0x00, 0x00,
    0x01, 0x68, 0xEB, 0xE3, 0xCB, 0x22, 0xC0, // PPS
    0x00, 0x00, 0x01, 0x65, 0x88, 0x84, 0x00, 0x9F, 0xEB, 0xEE, 0x88, 0xD3, 0xA4,
    0x92, // I slice
    0xF6, 0xF9, 0x71, 0x2C, 0x47, 0x99, 0xF4, 0xD8, 0xC1, 0xC1, 0x24, 0x59, 0xAC, 0x36, 0x51, 0x8C,
    0xA3, 0xC3, 0xA2, 0xB2, 0xB9, 0x50, 0x25, 0xC0, 0xFF, 0x9E, 0xA9, 0xC6, 0x1A, 0x4C, 0xA3, 0xE2,
    0x07, 0x28, 0x48, 0xE4, 0x78, 0xE5, 0xB2, 0x45, 0xA1, 0xD3, 0x6B, 0x98, 0x97, 0x4E, 0x4F, 0x42,
    0x9B, 0x85, 0xDF, 0x17, 0xF6, 0x53, 0xDD, 0x93, 0x72, 0x75, 0x3D, 0xAC, 0x69, 0x0C, 0x1B, 0xA5,
    0xC7, 0xBC, 0x50, 0xAF, 0x5D, 0x3F, 0x6B, 0xB5, 0x3A, 0x2E, 0x7F, 0x56, 0x9D, 0x63, 0x03, 0xB8,
    0xB5, 0x14, 0x9B, 0x2C, 0xDC, 0xE5, 0xF8, 0x34, 0x3F, 0x18, 0x8A, 0xBD, 0xF4, 0xB7, 0xD4, 0x76,
    0x4F, 0x9A, 0x25, 0xC1, 0xB1, 0x59, 0x91, 0x85, 0x6A, 0x9E, 0x76, 0x9D, 0x7A, 0xCB, 0xE7, 0xC4,
    0xE1, 0xC0, 0x25, 0x31, 0xBF, 0xEC, 0x36, 0x6E, 0x90, 0x93, 0xF6, 0x08, 0xF5, 0x13, 0x7F, 0x3D,
    0xDF, 0xC2, 0xBE, 0x57, 0xD4, 0xCC, 0xD7, 0xAD, 0xDC, 0xD2, 0xF5, 0xC9, 0x2C, 0x3D, 0xC4, 0x9F,
    0xE9, 0x09, 0x84, 0x1B, 0xB6, 0x69, 0xF3, 0x0B, 0xD6, 0x22, 0xB3, 0x41, 0x0A, 0xAD, 0xBE, 0xEA,
    0xEF, 0x3C, 0x8A, 0x7B, 0x07, 0x28, 0x4D, 0x24, 0x4F, 0xB2, 0x65, 0xE5, 0xCC, 0x45, 0x32, 0xE4,
    0x35, 0x82, 0xC3, 0xC8, 0x21, 0x5B, 0xA0, 0x7B, 0x3E, 0xB7, 0x70, 0xE2, 0x6A, 0x97, 0xC4, 0x2A,
    0xF6, 0x4D, 0xF2, 0xF0, 0x5B, 0x1C, 0xA8, 0xC1, 0xA7, 0xAF, 0x83, 0x56, 0x38, 0x0D, 0x79, 0x43,
    0xDA, 0x71, 0xF5, 0x1D, 0xD1, 0x34, 0xE2, 0xF1, 0x9B, 0xCF, 0x56, 0x5B, 0x3E, 0x31, 0x71, 0xD8,
    0x33, 0x40, 0x41, 0xF8, 0xA0, 0x6B, 0xD6, 0xA2, 0xAB, 0x19, 0xFE, 0x01, 0xF4, 0x00, 0x1D, 0x78,
    0x68, 0xF8, 0x64, 0xAC, 0x40, 0x63, 0x78, 0xAC, 0x38, 0x24, 0x11, 0xF0, 0x8A, 0x7C, 0x25, 0x06,
    0x6E, 0xEA, 0xC8, 0x2C, 0xFC, 0x89, 0x40, 0x0A, 0x26, 0xDB, 0x40, 0x29, 0x65, 0xF6, 0xCC, 0xB1,
    0xAD, 0x4B, 0x7D, 0xB4, 0xA3, 0xE6, 0x51, 0x33, 0xD9, 0x7B, 0xD1, 0xE2, 0x0C, 0x8E, 0x94, 0xEF,
    0x41, 0x2F, 0x61, 0xBE, 0xF8, 0xA4, 0x78, 0x74, 0x51, 0x17, 0xBD, 0xBB, 0x0E, 0x91, 0x33, 0xFA,
    0x92, 0xEF, 0x86, 0x6C, 0xC9, 0x24, 0x6D, 0x18, 0xB0, 0x4D, 0x34, 0xB0, 0x70, 0x20, 0x08, 0xC3,
    0x5A, 0x78, 0xA0, 0xFE, 0x5A, 0x52, 0x3B, 0xB5, 0x5B, 0xE2, 0x0A, 0x42, 0xD0, 0x0C, 0x16, 0x30,
    0x3D, 0x19, 0x35, 0x18, 0x9A, 0xE5, 0x0D, 0xF1, 0x31, 0x7B, 0x69, 0x20, 0x74, 0x06, 0x09, 0xFA,
    0x88, 0xC2, 0xA0, 0x1C, 0x30, 0x00, 0x5A, 0x9F, 0xA3, 0xEE, 0x74, 0x73, 0x2A, 0xE9, 0xE8, 0x62,
    0x58, 0xD3, 0x17, 0x3B, 0x1D, 0x57, 0xA2, 0x6F, 0x9E, 0x5E, 0x7D, 0xFB, 0xFA, 0x62, 0xEA, 0x54,
    0x14, 0x16, 0x43, 0xC2, 0xFD, 0xB9, 0x18, 0xC9, 0xED, 0x08, 0x1A, 0x2C, 0x5B, 0xE7, 0x1F, 0x51,
    0x85, 0xFF, 0xE5, 0x3C, 0x39, 0x17, 0xE2, 0xA4, 0x88, 0x95, 0xB9, 0xB0, 0xE0, 0x71, 0x14, 0x39,
    0x6F, 0x08, 0x5A, 0xD6, 0xD1, 0xCC, 0xC5, 0x82, 0x10, 0x73, 0x88, 0x9B, 0x0A, 0x3A, 0xD0, 0x21,
    0x4F, 0x6B, 0x7D, 0x93, 0xF4, 0x52, 0xD6, 0xA7, 0x05, 0xF5, 0x42, 0xD6, 0xC8, 0x01, 0x10, 0x1B,
    0x39, 0x35, 0x24, 0x75, 0x5F, 0x6B, 0x47, 0x5D, 0x2F, 0x68, 0xA0, 0x08, 0x66, 0x9E, 0x74, 0x2B,
    0xF0, 0x9F, 0x75, 0x75, 0x59, 0xFA, 0xEA, 0xF3, 0xDB, 0x8F, 0xBD, 0x5C, 0xED, 0xBB, 0x16, 0x5D,
    0x85, 0x46, 0xD1, 0x8F, 0xB6, 0x09, 0x36, 0x02, 0x25, 0x22, 0xA3, 0xB1, 0x43, 0xA6, 0x5F, 0x8C,
    0xC2, 0x78, 0xDC, 0xAC, 0x4C, 0xB8, 0xFD, 0xB3, 0xA2, 0x12, 0xEC, 0x13, 0x2E, 0xC9, 0x56, 0x38,
    0x13, 0xDB, 0xCE, 0xDC, 0xF9, 0xD7, 0x08, 0x65, 0x26, 0x6C, 0xEE, 0x31, 0xE5, 0x47, 0x58, 0xC3,
    0x38, 0xA2, 0x93, 0x82, 0xDC, 0x96, 0x7E, 0x84, 0xD2, 0x49, 0xFA, 0xB3, 0x71, 0x8C, 0x5E, 0xCE,
    0xFB, 0xE4, 0x07, 0x07, 0x43, 0xC4, 0x49, 0x6A, 0x83, 0x51, 0x89, 0x24, 0x59, 0x2C, 0xD3, 0xCD,
    0xD2, 0xAB, 0xFA, 0x87, 0xA4, 0x64, 0xA2, 0x94, 0x94, 0x9F, 0xCB, 0x5E, 0x33, 0x89, 0x63, 0xB2,
    0x9A, 0x0D, 0xF4, 0xE9, 0x77, 0xC0, 0x17, 0xFC, 0x5D, 0x87, 0x92, 0x1D, 0x29, 0x93, 0xE4, 0x68,
    0x42, 0x2C, 0x1C, 0xA5, 0xF9, 0xAC, 0x56, 0x38, 0x95, 0x07, 0x26, 0x9B, 0xA3, 0x52, 0xAE, 0x98,
    0x13, 0x74, 0xA7, 0x4D, 0x97, 0xE5, 0x99, 0xDC, 0xDA, 0x4D, 0xDE, 0x7A, 0xD7, 0x88, 0x58, 0xBD,
    0x6A, 0x57, 0x61, 0xFE, 0x9D, 0xBB, 0xDC, 0x93, 0x89, 0x74, 0xF3, 0x59, 0x18, 0x4D, 0x94, 0x09,
    0xAE, 0x4B, 0x11, 0xCC, 0xFF, 0x31, 0x8B, 0x2E, 0xD2, 0x30, 0x71, 0x3D, 0x91, 0xDC, 0x94, 0xB3,
    0x99, 0x5F, 0x88, 0xC7, 0x92, 0x8D, 0xE6, 0x5A, 0x33, 0x2E, 0xA3, 0x68, 0xE5, 0xAA, 0x43, 0xA6,
    0x3E, 0x4B, 0x0D, 0x3A, 0xCC, 0x6F, 0x1E, 0x36, 0x54, 0xB5, 0x42, 0xE9, 0x03, 0x77, 0x89, 0xDB,
    0x6F, 0xA7, 0x96, 0xF8, 0x09, 0xD8, 0xF0, 0xC5, 0xDA, 0x51, 0x22, 0x97, 0x86, 0xD5, 0x49, 0x6F,
    0xB9, 0x66, 0x97, 0x13, 0xDB, 0x6B, 0x82, 0xA5, 0x81, 0xD0, 0xDD, 0xB4, 0x50, 0x6A, 0x68, 0x6C,
    0xAE, 0x47, 0x60, 0xB6, 0xA6, 0x99, 0x41, 0x92, 0xB3, 0x5B, 0xB5, 0x70, 0x11, 0x40, 0x68, 0x1D,
    0xDC, 0x28, 0x72, 0x41, 0x22, 0xBF, 0xE0, 0x08, 0x71, 0x2F, 0x23, 0x67, 0xE3, 0xE6, 0x2D, 0x92,
    0x14, 0x4A, 0xE4, 0x72, 0xE6, 0xDA, 0xCC, 0x70, 0x80, 0x0B, 0xBA, 0x78, 0xEF, 0x34, 0xB3, 0x1B,
    0xB0, 0x89, 0x05, 0x53, 0x65, 0xBA, 0x43, 0xA0, 0x39, 0x9A, 0x30, 0xEC, 0x21, 0xCB, 0xC4, 0xBB,
    0x68, 0xEB, 0x04, 0xBB, 0x0E, 0x48, 0x21, 0xB1, 0x97, 0xA5, 0x74, 0x20, 0x32, 0xF2, 0x4D, 0x3F,
    0x87, 0x72, 0x75, 0xA0, 0xA2, 0x67, 0x84, 0x3A, 0xC3, 0xF4, 0x52, 0x0A, 0x8B, 0x56, 0x18, 0x33,
    0x8D, 0xFC, 0x01, 0xE4, 0x9D, 0x1B, 0x5E, 0x5E, 0x78, 0x0F, 0xB1, 0x35, 0xD6, 0x97, 0xCC, 0x38,
    0x5A, 0xCF, 0x6E, 0x7B, 0x00, 0x1F, 0xC8, 0x00, 0xAE, 0xE5, 0x50, 0x2C, 0xA5, 0xBE, 0x32, 0x85,
    0x29, 0xA7, 0x7F, 0x87, 0xFE, 0x09, 0x9F, 0xC6, 0x68, 0x9C, 0x8E, 0x7D, 0x28, 0x99, 0xA9, 0x0C,
    0x5A, 0x19, 0x4F, 0x0E, 0xD8, 0xA5, 0x83, 0x9E, 0xDD, 0x0D, 0xCF, 0xF5, 0x27, 0xF6, 0x15, 0x81,
    0x28, 0x64, 0x34, 0xB6, 0xA9, 0x86, 0x0E, 0xF8, 0xC8, 0x5D, 0x39, 0xBC, 0x03, 0xA8, 0x76, 0x3C,
    0x52, 0xE6, 0x6D, 0x83, 0x07, 0x79, 0x4C, 0x09, 0x26, 0x87, 0x7A, 0x15, 0x8B, 0xC1, 0x34, 0xC1,
    0x8A, 0x07, 0x1B, 0xF4, 0x91, 0xDB, 0x75, 0xC3, 0x8C, 0xE5, 0xF0, 0xDD, 0xDA, 0xE0, 0x47, 0x94,
    0xBB, 0x0F, 0x3C, 0xA7, 0xF0, 0x06, 0xCF, 0x53, 0x9F, 0xB2, 0xCE, 0xB3, 0x25, 0xDB, 0xE3, 0x2D,
    0x4F, 0x14, 0xB2, 0x8F, 0x65, 0x97, 0x89, 0x48, 0x80, 0x91, 0x0F, 0x8C, 0xDA, 0x0D, 0xF5, 0x8F,
    0x67, 0xF8, 0x64, 0x18, 0xDE, 0x8F, 0x09, 0x7D, 0xCA, 0x6F, 0x98, 0xF4, 0x3E, 0xFA, 0xF8, 0xD9,
    0xC8, 0xA0, 0x36, 0x59, 0x42, 0xEE, 0x85, 0xD0, 0x9F, 0x26, 0x05, 0x22, 0xEC, 0x3D, 0xCA, 0x92,
    0x8B, 0x49, 0x8B, 0x9F, 0xE4, 0xA4, 0x3C, 0xD0, 0x9C, 0x98, 0x09, 0xAC, 0x21, 0xE5, 0x00, 0xCD,
    0x99, 0xEE, 0x50, 0x67, 0xE3, 0x50, 0x52, 0x5B, 0xC8, 0x07, 0xBF, 0xEF, 0x22, 0xB5, 0x35, 0x2F,
    0xF2, 0xD6, 0xBA, 0x83, 0x0A, 0xCB, 0x13, 0xAD, 0xC3, 0xEA, 0x8E, 0xF3, 0x02, 0x42, 0x81, 0xA7,
    0x02, 0x28, 0x4F, 0x4B, 0x00, 0x9C, 0xB1, 0x20, 0xBA, 0xFB, 0xE3, 0x41, 0x10, 0xB0, 0x98, 0x99,
    0xCA, 0xD4, 0xFA, 0xF3, 0xB6, 0xAF, 0x15, 0x79, 0x9C, 0x99, 0x3C, 0xF4, 0x44, 0xA7, 0xDE, 0x4C,
    0x2D, 0x2D, 0x09, 0x51, 0xAC, 0xEA, 0x01, 0x33, 0x64, 0x34, 0x33, 0xBC, 0x23, 0xA4, 0xD6, 0x4E,
    0xF1, 0x24, 0x2C, 0x41, 0x5F, 0xED, 0x01, 0xB5, 0xF3, 0xA5, 0xB2, 0x66, 0x11, 0x68, 0x58, 0xDD,
    0x1E, 0xE9, 0x48, 0x26, 0xB9, 0xAE, 0x40, 0xF3, 0xC1, 0x14, 0xB1, 0x4F, 0xA5, 0xDF, 0x8F, 0x5A,
    0x9B, 0xA5, 0x11, 0x53, 0xF8, 0x81, 0x4B, 0x80, 0x8C, 0x80, 0xF5, 0x10, 0x2A, 0x6E, 0xAE, 0x57,
    0x20, 0x3B, 0xBE, 0x03, 0xED, 0x18, 0xB0, 0x27, 0x4D, 0xF5, 0x65, 0xB7, 0x9B, 0x24, 0x0A, 0xC0,
    0xB4, 0x0C, 0xE3, 0xFC, 0x98, 0x52, 0xE6, 0x93, 0x09, 0x05, 0x25, 0x1D, 0xD7, 0x65, 0xCD, 0x97,
    0xED, 0x37, 0x9E, 0xC6, 0xD8, 0xAB, 0xD2, 0xF5, 0xDB, 0xD0, 0x91, 0x00, 0x64, 0x36, 0x06, 0xE1,
    0xFC, 0xCB, 0x16, 0xD0, 0x9B, 0xE4, 0x21, 0x88, 0x6C, 0x6D, 0x2C, 0x5A, 0x34, 0x75, 0x9A, 0x3A,
    0xC2, 0xF4, 0xB9, 0x87, 0xA2, 0x68, 0xEC, 0xE6, 0x91, 0x9D, 0xB9, 0xEC, 0xC5, 0xCB, 0x13, 0xDA,
    0x42, 0x6C, 0xC4, 0xBE, 0x23, 0xD3, 0x86, 0xBC, 0x9E, 0x69, 0x37, 0xD3, 0x7F, 0x38, 0xCE, 0x55,
    0x12, 0xB7, 0x8D, 0x35, 0x20, 0xBE, 0x91, 0x3E, 0x0E, 0xE1, 0x33, 0xB6, 0x55, 0x05, 0x31, 0x3A,
    0xF9, 0x51, 0x97, 0x07, 0x73, 0x46, 0xCF, 0x8B, 0xA6, 0x50, 0xE9, 0x11, 0x8D, 0x68, 0x99, 0xE2,
    0x9A, 0x56, 0xA4, 0x8C, 0xD3, 0x6E, 0x71, 0xEC, 0x4B, 0x55, 0xF8, 0xD0, 0x6E, 0xD8, 0x9D, 0x19,
    0x62, 0xBF, 0x36, 0x52, 0xF0, 0xD4, 0xE7, 0x06, 0x64, 0x2D, 0xDC, 0x10, 0xCC, 0x6B, 0xC4, 0x2B,
    0x8E, 0x16, 0x03, 0x81, 0xFA, 0xE0, 0x67, 0x70, 0x72, 0xDE, 0x8E, 0xC6, 0xE0, 0x56, 0x65, 0x8E,
    0xAB, 0x5C, 0xEF, 0xE1, 0x17, 0xD0, 0xEF, 0x0A, 0xBF, 0xF0, 0x51, 0x71, 0xE1, 0xAE, 0x31, 0x06,
    0x14, 0x69, 0xD6, 0xCA, 0x63, 0x2B, 0xF4, 0xD1, 0xC2, 0x13, 0x0D, 0x5C, 0x38, 0xC1, 0x02, 0xCC,
    0x43, 0x0D, 0x09, 0x53, 0xBD, 0x43, 0x62, 0x83, 0x59, 0x01, 0xCB, 0x4C, 0xC2, 0xB8, 0x1B, 0xC7,
    0x8B, 0x0D, 0x02, 0xCD, 0x7A, 0x08, 0x8B, 0xCD, 0x30, 0x9D, 0xEA, 0xAD, 0x2C, 0xF2, 0x8A, 0xB2,
    0x8A, 0x7E, 0x79, 0x84, 0xE2, 0x16, 0x82, 0x8A, 0xA4, 0x90, 0x0D, 0x95, 0xDA, 0x3B, 0xC8, 0x18,
    0x87, 0x85, 0x44, 0x46, 0x98, 0xD7, 0xE0, 0xDE, 0x58, 0xFE, 0x6A, 0xE2, 0xFA, 0x96, 0x16, 0xD4,
    0x60, 0xB3, 0xBA, 0x03, 0xE6, 0xA4, 0x0A, 0x8E, 0x9B, 0x20, 0x56, 0x9B, 0x2D, 0x94, 0x31, 0x26,
    0x09, 0x51, 0xEC, 0x1A, 0xB2, 0xCA, 0xAA, 0x8A, 0x0F, 0x16, 0xA3, 0x35, 0x7B, 0xBE, 0xC2, 0x30,
    0xA3, 0xD2, 0x00, 0x06, 0x6F, 0x53, 0x3A, 0xF1, 0xB9, 0xEF, 0x20, 0x6A, 0xB2, 0x54, 0xEA, 0xE0,
    0xEC, 0xE5, 0xB9, 0x19, 0xFD, 0xA5, 0x4B, 0xF8, 0x6D, 0x9D, 0x10, 0x5C, 0xD1, 0x55, 0x6F, 0xE8,
    0xB7, 0x17, 0xCD, 0x1A, 0xDD, 0xFE, 0xE1, 0x61, 0xE7, 0x41, 0xB9, 0xD1, 0x40, 0x89, 0xD8, 0x87,
    0x3F, 0x40, 0xFE, 0xAE, 0xC8, 0x16, 0xFC, 0x41, 0x43, 0xF8, 0xA1, 0xB0, 0xD8, 0xE2, 0xD6, 0xCF,
    0x98, 0xDE, 0xF5, 0xAF, 0x9C, 0xEA, 0xB4, 0xC4, 0x94, 0xA1, 0x99, 0xCF, 0x91, 0x3D, 0x09, 0xAE,
    0xCF, 0x0D, 0xAA, 0x29, 0xD4, 0x18, 0xDD, 0x8A, 0xD7, 0xF2, 0xB6, 0xD4, 0x54, 0x1A, 0x86, 0xF4,
    0x33, 0x82, 0xDC, 0x86, 0x27, 0xD8, 0x15, 0x5A, 0xE1, 0x49, 0x96, 0xCC, 0xCB, 0x93, 0x26, 0x36,
    0x31, 0x3A, 0x34, 0x16, 0xFC, 0x20, 0xA6, 0xD9, 0x66, 0x99, 0x01, 0x53, 0xF3, 0xA6, 0xAF, 0xE7,
    0x15, 0xFC, 0x5A, 0x84, 0x51, 0x39, 0xF5, 0x3B, 0x6C, 0xE6, 0xD8, 0x35, 0xB9, 0x92, 0xDC, 0xD9,
    0xDA, 0xC4, 0x22, 0x15, 0x48, 0xEE, 0x56, 0xE0, 0x52, 0x08, 0x9A, 0x7C, 0xBD, 0x4E, 0x4A, 0xDB,
    0xE8, 0xB0, 0x16, 0xAF, 0xE2, 0xB2, 0xE0, 0x18, 0x86, 0xDD, 0xA8, 0x1C, 0x06, 0x4B, 0x0C, 0x02,
    0x00, 0xBD, 0xE9, 0x84, 0x73, 0xC4, 0x9F, 0xAE, 0x6E, 0x42, 0x93, 0x51, 0xE5, 0xA7, 0xD8, 0xC5,
    0x54, 0xDF, 0x3D, 0x5B, 0x04, 0x00, 0x27, 0xF2, 0x33, 0x1D, 0x98, 0x8B, 0x53, 0x9F, 0x2C, 0xC2,
    0x95, 0x89, 0x80, 0xAC, 0x78, 0xBB, 0x36, 0xE6, 0x45, 0xA7, 0x7F, 0x4C, 0xDB, 0xCB, 0xF8, 0xA8,
    0x25, 0x18, 0x51, 0x1E, 0x1E, 0xA1, 0xAB, 0x91, 0xA7, 0x16, 0x98, 0x31, 0xA5, 0x8D, 0x6A, 0x5C,
    0x93, 0x3E, 0x45, 0x17, 0x84, 0x72, 0xA4, 0xF4, 0x35, 0xC3, 0xAE, 0xB1, 0xD4, 0xEF, 0x85, 0x4C,
    0x25, 0x26, 0x74, 0xDB, 0x67, 0x00, 0x8B, 0x42, 0x3E, 0x72, 0x71, 0xBC, 0xAB, 0x25, 0x62, 0x16,
    0x70, 0x42, 0x2E, 0xB1, 0xB3, 0xE4, 0xAB, 0x5B, 0x56, 0xEC, 0x3B, 0xB4, 0x4A, 0x60, 0x13, 0xCF,
    0xD1, 0x12, 0x45, 0x44, 0x69, 0x8D, 0xED, 0x7B, 0xA9, 0xD9, 0xD1, 0x87, 0x25, 0xF0, 0xF9, 0x99,
    0xDC, 0xAC, 0xA9, 0xDF, 0x1F, 0xE4, 0xDE, 0xDD, 0x66, 0x8F, 0xED, 0x39, 0x7B, 0x55, 0x8A, 0x4F,
    0x0C, 0xEC, 0xAD, 0x84, 0xD7, 0x89, 0xF2, 0xD6, 0x17, 0xD9, 0xB7, 0xAB, 0x9C, 0x5D, 0x40, 0xB0,
    0xB1, 0x2D, 0x5C, 0x4F, 0x85, 0xED, 0xFE, 0xBE, 0xB6, 0x37, 0xEC, 0x72, 0xB8, 0xEB, 0x1B, 0x9C,
    0x5B, 0x43, 0x8D, 0xFF, 0x00, 0xE1, 0xA4, 0xDD, 0x41, 0x36, 0x9D, 0xF8, 0x55, 0x9C, 0x60, 0x36,
    0xD0, 0x36, 0xC1, 0xA6, 0xCC, 0xD2, 0x91, 0x60, 0x34, 0x89, 0xAE, 0x1F, 0x87, 0xCD, 0x64, 0xA0,
    0xDC, 0x21, 0x5F, 0x00, 0x2E, 0xB5, 0xD2, 0x9F, 0x0B, 0x51, 0x21, 0x8E, 0x0D, 0x3D, 0x4F, 0xAE,
    0x1F, 0x60, 0x2C, 0x21, 0x9F, 0x18, 0x87, 0x36, 0xB5, 0x98, 0x0A, 0x2E, 0xBE, 0x72, 0xF0, 0xCA,
    0xAF, 0x7C, 0x0C, 0x46, 0xBE, 0xA3, 0x5D, 0x4E, 0x94, 0x60, 0xF9, 0x08, 0x6A, 0x7A, 0x4D, 0x84,
    0xAC, 0xA9, 0x5E, 0x8A, 0x07, 0xA4, 0x2C, 0x70, 0x40, 0x40, 0x7F, 0x93, 0x19, 0x0E, 0xE4, 0x07,
    0x1A, 0xA9, 0xC2, 0x1D, 0x8E, 0x7C, 0x04, 0x8E, 0x27, 0xC3, 0xD8, 0x25, 0xDA, 0xA6, 0x49, 0x97,
    0x6F, 0xDC, 0xA4, 0xDD, 0x34, 0x6D, 0x3F, 0x85, 0x77, 0x09, 0x44, 0xD7, 0xFC, 0xD2, 0x2E, 0x3F,
    0xC6, 0xCA, 0x58, 0x79, 0xFA, 0x36, 0x29, 0x45, 0x40, 0xC5, 0x47, 0x20, 0xF8, 0x68, 0xC0, 0x57,
    0xA1, 0x24, 0xC7, 0xD3, 0x14, 0x3B, 0x43, 0xE2, 0xD0, 0x26, 0xD7, 0x1A, 0xA6, 0x99, 0xC9, 0xCF,
    0x06, 0x5D, 0xDA, 0xA1, 0xBB, 0xF0, 0x31, 0xCD, 0xB8, 0x24, 0xF3, 0xF1, 0x69, 0x98, 0x93, 0x20,
    0x71, 0xC9, 0x15, 0x29, 0x87, 0x35, 0x1D, 0xE4, 0xA7, 0xF6, 0x46, 0x5B, 0xE0, 0x59, 0x61, 0x1F,
    0xCD, 0xEF, 0xC7, 0x38, 0x1D, 0x9B, 0x44, 0x82, 0x47, 0x75, 0xEC, 0x8A, 0x8A, 0x17, 0x9F, 0x07,
    0xB1, 0x2F, 0xBD, 0x94, 0xC2, 0x88, 0x65, 0x2B, 0x86, 0xA9, 0xB7, 0x08, 0xFA, 0x4A, 0x9B, 0x5A,
    0xBB, 0xA9, 0x37, 0xDD, 0xDC, 0x0D, 0xD7, 0x82, 0x38, 0x30, 0x27, 0xDA, 0x93, 0x6F, 0x35, 0x6B,
    0xA3, 0x8F, 0xF8, 0x8D, 0xF5, 0x38, 0x87, 0xD9, 0x92, 0x74, 0x9F, 0xE1, 0x05, 0x51, 0xE8, 0xC6,
    0x96, 0xB9, 0x84, 0x95, 0xC6, 0xD7, 0x39, 0x9B, 0x57, 0x17, 0x08, 0xA5, 0xB1, 0x69, 0xBF, 0x75,
    0x96, 0x61, 0xC2, 0x77, 0xCA, 0xA7, 0x62, 0xB3, 0xFD, 0x16, 0x37, 0x4B, 0x25, 0x01, 0xA3, 0xA8,
    0x0A, 0x75, 0x66, 0xBB, 0xAF, 0x9C, 0x12, 0x39, 0x22, 0x5B, 0xEA, 0xED, 0xA0, 0xFD, 0xAE, 0x62,
    0x33, 0x0B, 0xCE, 0xB6, 0x42, 0xC7, 0x8F, 0x55, 0xBC, 0xC0, 0x56, 0x58, 0x4E, 0xC5, 0x4F, 0x2F,
    0xF8, 0x44, 0xE9, 0x97, 0xED, 0x7D, 0xC8, 0xB2, 0x24, 0x00, 0xF9, 0xFB, 0xBF, 0xB6, 0x49, 0x96,
    0x09, 0xC6, 0xD7, 0x02, 0x1D, 0x29, 0x64, 0x0D, 0x51, 0x6D, 0xDF, 0x3D, 0x65, 0x4F, 0xE8, 0x09,
    0xDC, 0xBF, 0x65, 0x64, 0x65, 0x7A, 0x85, 0x35, 0xD2, 0x91, 0x15, 0x44, 0xA2, 0xE6, 0x09, 0x7D,
    0xA0, 0xEC, 0x62, 0x2F, 0xC0, 0xCB, 0x4E, 0xC2, 0xC7, 0x7B, 0x65, 0x2A, 0x30, 0xB6, 0xE8, 0x80,
    0x7F, 0xE6, 0x36, 0x64, 0x32, 0xFC, 0xC4, 0xB7, 0x5A, 0xF2, 0xBE, 0x62, 0x7E, 0x9C, 0x82, 0xBB,
    0x77, 0x11, 0xBA, 0x05, 0x47, 0x4B, 0xE9, 0x93, 0x32, 0xC6, 0x54, 0x4D, 0xE1, 0x00, 0xE9, 0xDA,
    0xFB, 0xC7, 0xFD, 0xCF, 0xCD, 0x6A, 0xAB, 0x6A, 0xDB, 0x2E, 0xFD, 0xE3, 0x05, 0x06, 0x77, 0xD5,
    0xDA, 0x78, 0x9D, 0x2E, 0x3D, 0x3F, 0xAA, 0xDE, 0x5D, 0x84, 0x84, 0x36, 0xE1, 0x07, 0xD8, 0xF4,
    0xD1, 0x65, 0x97, 0x86, 0xE9, 0x62, 0x3C, 0x6E, 0x76, 0xE8, 0x35, 0x8D, 0xC9, 0xFD, 0x86, 0x1D,
    0x4C, 0x7E, 0x7A, 0x9E, 0x6E, 0x83, 0x36, 0xF4, 0x16, 0xC8, 0x88, 0xBD, 0x1D, 0x44, 0xB9, 0x0E,
    0xED, 0xA0, 0xF4, 0xDA, 0xA4, 0x4F, 0xD4, 0xB6, 0x11, 0x54, 0x19, 0x18, 0xA9, 0x9E, 0xE8, 0x42,
    0x75, 0x50, 0xD7, 0x68, 0x0F, 0x69, 0x0E, 0x12, 0x67, 0x9E, 0x6D, 0xD9, 0x09, 0x26, 0x80, 0x77,
    0xCA, 0x4E, 0x68, 0xA3, 0x61, 0x7A, 0x3D, 0x3F, 0x01, 0x4C, 0xDF, 0x9A, 0xFE, 0x08, 0x2F, 0x78,
    0x21, 0x4D, 0x08, 0x68, 0x3F, 0xD3, 0xC9, 0x16, 0xF2, 0x09, 0x40, 0x83, 0x04, 0x7F, 0x7D, 0x48,
    0xD1, 0x9A, 0x9E, 0xD7, 0x5D, 0xAD, 0x4D, 0x31, 0x92, 0x23, 0x31, 0x88, 0x56, 0xD0, 0x52, 0x11,
    0x6F, 0x1B, 0x94, 0xEB, 0x97, 0x53, 0xB2, 0x03, 0xA4, 0x4C, 0xD3, 0xB4, 0x10, 0x0C, 0xE2, 0x83,
    0x16, 0x2A, 0x2C, 0xEF, 0xFE, 0xA4, 0x9C, 0x72, 0x2B, 0xD4, 0x4D, 0xA4, 0xDD, 0x55, 0x93, 0x44,
    0xE8, 0xAC, 0xCE, 0xC7, 0x17, 0xED, 0x59, 0x88, 0x34, 0x29, 0x2C, 0x41, 0x34, 0xD1, 0x51, 0xA1,
    0xB8, 0xEB, 0xC4, 0x0C, 0xF9, 0x03, 0xEB, 0xFC, 0xE8, 0x52, 0x04, 0xC4, 0x6D, 0x6D, 0x71, 0x37,
    0xE3, 0x1C, 0xD6, 0x72, 0x48, 0x2B, 0xA5, 0xD0, 0x7B, 0x00, 0xBC, 0x90, 0x5F, 0x6E, 0xD1, 0xE7,
    0xC7, 0xC5, 0xB1, 0xD9, 0x58, 0xA2, 0x2F, 0xAC, 0x8D, 0xB7, 0x71, 0x1A, 0xF7, 0xE5, 0xFC, 0xDC,
    0x3B, 0x5D, 0xF4, 0xC8, 0x88, 0xBE, 0x19, 0x73, 0x6D, 0xFE, 0x59, 0xBD, 0xED, 0xB5, 0x04, 0xA7,
    0xF5, 0xB4, 0xA0, 0xA8, 0x89, 0x13, 0x0D, 0x9B, 0xE7, 0x7D, 0x51, 0x90, 0xC1, 0x84, 0x53, 0x89,
    0x6A, 0x4F, 0xAC, 0x92, 0x5D, 0xB2, 0x73, 0xF1, 0xC7, 0xBB, 0x80, 0xB1, 0x4E, 0xBC, 0xA6, 0xBD,
    0xA1, 0x7E, 0x2A, 0x44, 0xE3, 0x34, 0xC9, 0x61, 0x8C, 0xFC, 0xF7, 0x0E, 0x4D, 0xEB, 0x35, 0xE5,
    0x01, 0x79, 0xE6, 0xF5, 0xA6, 0x76, 0x99, 0x4D, 0xFF, 0xAE, 0xFB, 0x93, 0xB8, 0x81, 0x36, 0x55,
    0x51, 0x66, 0x4A, 0x58, 0x22, 0x2B, 0x87, 0x13, 0x70, 0x74, 0xBB, 0xEE, 0x0F, 0x79, 0x6A, 0xBB,
    0x71, 0xDD, 0x3F, 0x76, 0xB1, 0x12, 0x5C, 0x69, 0x99, 0x52, 0xA2, 0xB6, 0x6F, 0xEC, 0x24, 0x5C,
    0x6A, 0x4C, 0x31, 0x23, 0xF6, 0xB7, 0xBC, 0x33, 0x7F, 0x9E, 0x1E, 0x70, 0xFF, 0x2A, 0x65, 0xDB,
    0x5E, 0xBD, 0x2B, 0xF2, 0x07, 0x56, 0xE0, 0x5E, 0xBC, 0x89, 0x51, 0xE4, 0xA0, 0x18, 0x31, 0xB9,
    0xD2, 0xE1, 0x1E, 0x68, 0x33, 0xB0, 0xAB, 0xD5, 0x2A, 0x8F, 0x7A, 0xAB, 0x2F, 0x5C, 0x4B, 0xB9,
    0xC6, 0x01, 0x28, 0x0D, 0x13, 0xE8, 0xB4, 0xE5, 0xAF, 0xAC, 0x19, 0x82, 0x0E, 0x11, 0x28, 0x9D,
    0x9F, 0x7B, 0xEA, 0x26, 0xC1, 0xB8, 0xE8, 0x4C, 0x49, 0x63, 0xD9, 0x8A, 0x63, 0x4C, 0xCC, 0x06,
    0x76, 0x63, 0x12, 0x73, 0x4B, 0x3A, 0xFF, 0x87, 0x3D, 0xC6, 0xFB, 0x39, 0xA1, 0xF6, 0x95, 0xFE,
    0xE6, 0x3C, 0x0A, 0x5F, 0x91, 0xD1, 0x6F, 0xE7, 0x73, 0x31, 0x64, 0x67, 0xB9, 0xBA, 0x1E, 0xFD,
    0xE5, 0x57, 0x99, 0x6D, 0xF7, 0xA4, 0x1B, 0xA5, 0x84, 0x56, 0xBC, 0x39, 0x21, 0xF2, 0x79, 0x2A,
    0x6E, 0xED, 0xA5, 0x7B, 0x6E, 0xFE, 0x33, 0x13, 0xF6, 0xD5, 0x63, 0x4A, 0xF2, 0xA8, 0x9D, 0x55,
    0x31, 0x50, 0xA4, 0x72, 0xBF, 0xDE, 0xD5, 0xB6, 0xC7, 0xB2, 0x7B, 0xC8, 0xA8, 0xB0, 0x83, 0x98,
    0x9D, 0x34, 0x4B, 0x34, 0xFD, 0x93, 0x71, 0x9D, 0x42, 0x63, 0xC5, 0xF6, 0xBB, 0x5D, 0xB7, 0xB1,
    0x74, 0x9A, 0x17, 0x7C, 0x35, 0x33, 0xF6, 0xCB, 0x7B, 0xB5, 0x88, 0x86, 0x1F, 0x03, 0xA0, 0xF5,
    0xB6, 0x83, 0xF6, 0x68, 0xF1, 0x60, 0xBC, 0xED, 0xD3, 0xCC, 0x51, 0x4D, 0xD3, 0x7E, 0x29, 0xB0,
    0x99, 0xE7, 0x09, 0x14, 0x02, 0x23, 0xE1, 0x14, 0xF7, 0x55, 0x83, 0x74, 0xF1, 0x14, 0x1B, 0x90,
    0xC3, 0x30, 0x82, 0xE7, 0x1B, 0x6D, 0xAD, 0x71, 0xC0, 0x21, 0x5D, 0xDE, 0x4B, 0xDC, 0x85, 0xE6,
    0xB5, 0xC4, 0x56, 0x06, 0x84, 0x4E, 0xB0, 0x7D, 0x95, 0xB0, 0xEC, 0x39, 0x2D, 0x7C, 0x4C, 0xDC,
    0xAB, 0x23, 0x81, 0xDE, 0xBB, 0xE5, 0xEC, 0x15, 0xFD, 0x0C, 0x36, 0x68, 0x97, 0x62, 0x4E, 0x7B,
    0x49, 0xC2, 0xCF, 0x3C, 0xD6, 0xD9, 0x26, 0xC8, 0x9E, 0xE8, 0x1C, 0x99, 0xEC, 0x64, 0x43, 0x98,
    0xF5, 0x8D, 0x1F, 0xC6, 0xCA, 0xCD, 0x4C, 0x1A, 0xE1, 0xD1, 0x88, 0x41, 0x5C, 0xB6, 0xA9, 0x2B,
    0xCA, 0xEA, 0x76, 0x5C, 0x37, 0xC7, 0xD6, 0x6F, 0x78, 0xD0, 0x57, 0x31, 0x49, 0x2F, 0x04, 0xF3,
    0x4C, 0x83, 0xBE, 0xD0, 0xAD, 0x08, 0x89, 0x74, 0xBA, 0x70, 0x27, 0x86, 0x6F, 0x26, 0x64, 0x0B,
    0x07, 0x30, 0x70, 0x2A, 0x5C, 0x03, 0xEF, 0xAD, 0xE9, 0x3F, 0x3E, 0x1C, 0xCC, 0x83, 0xD0, 0xB3,
    0x7D, 0xA7, 0xC1, 0x59, 0x8E, 0xC1, 0xCE, 0xD3, 0xBC, 0xBA, 0x7C, 0x4F, 0xB5, 0x40, 0x75, 0x90,
    0x10, 0x0F, 0x3C, 0x4E, 0xF9, 0xAD, 0xE1, 0x8B, 0xC2, 0x3B, 0x59, 0x8E, 0xFF, 0xDF, 0x41, 0xFF,
    0xAD, 0xB9, 0x0E, 0xE8, 0xEC, 0x72, 0x99, 0xC7, 0x1F, 0xA5, 0xEB, 0x51, 0x14, 0x07, 0x39, 0x00,
    0x75, 0x88, 0x51, 0x0D, 0x73, 0x3B, 0x7E, 0xD1, 0x7E, 0x73, 0x3E, 0xC1, 0xFB, 0x91, 0x5C, 0xEB,
    0xF9, 0xF7, 0x20, 0xDB, 0xA2, 0xCF, 0xC8, 0x23, 0xCB, 0xF7, 0x11, 0x94, 0xF4, 0x3D, 0xDF, 0xF2,
    0xD8, 0x4C, 0x62, 0x2A, 0x94, 0x5D, 0x2A, 0x55, 0x7D, 0x7C, 0xFC, 0x7C, 0xE5, 0xDC, 0x71, 0xA7,
    0x5B, 0x59, 0x43, 0x76, 0x4D, 0x62, 0x16, 0x8A, 0xD9, 0xDD, 0xF8, 0xC2, 0xBE, 0x77, 0xEA, 0x70,
    0xC9, 0x38, 0x01, 0x0D, 0xA8, 0x91, 0x97, 0xCC, 0x20, 0x92, 0x2D, 0x0F, 0xF7, 0xAE, 0xC2, 0x63,
    0x07, 0x74, 0xD7, 0x1F, 0xFC, 0xCC, 0xC3, 0x6B, 0xEB, 0x10, 0xA6, 0xBF, 0xB4, 0x65, 0xB7, 0x4B,
    0xC3, 0xA7, 0xFA, 0x43, 0x28, 0x96, 0x51, 0x7B, 0xE4, 0x27, 0x8E, 0xBF, 0x19, 0x9D, 0x9C, 0x9B,
    0xAD, 0xB9, 0x4F, 0x07, 0xB3, 0xBE, 0xC2, 0x62, 0xFC, 0x9D, 0x20, 0x4B, 0x3F, 0xE6, 0x80, 0x81,
    0x41, 0x15, 0xA7, 0x48, 0x05, 0x19, 0xF0, 0x09, 0x2D, 0xFD, 0xBE, 0x65, 0xB6, 0x57, 0x44, 0x67,
    0xB1, 0x46, 0x37, 0x9A, 0x79, 0xEF, 0x97, 0x9A, 0x08, 0x8A, 0x21, 0x8C, 0x27, 0x62, 0x0B, 0x0E,
    0xFB, 0x68, 0x63, 0xC2, 0x67, 0x02, 0x18, 0x2C, 0xFB, 0x0B, 0x85, 0x1F, 0x86, 0x80, 0xFC, 0x58,
    0xA8, 0xC9, 0xD4, 0x89, 0x67, 0xD0, 0x38, 0x58, 0xEF, 0x6A, 0x01, 0xD3, 0x7F, 0xD2, 0x12, 0xC7,
    0x60, 0x63, 0xBF, 0x21, 0x77, 0xF4, 0x21, 0x95, 0x91, 0x8A, 0x04, 0x08, 0x4D, 0x4A, 0x92, 0xE2,
    0xC6, 0x9E, 0x1B, 0xCF, 0xC3, 0x98, 0x6F, 0x51, 0x22, 0x2E, 0x95, 0x75, 0xB4, 0x85, 0x85, 0x5A,
    0xC7, 0x44, 0x1E, 0x96, 0x83, 0x96, 0xCA, 0x19, 0xAE, 0xBD, 0xD7, 0x39, 0xBB, 0x22, 0x26, 0xBE,
    0x50, 0xFF, 0x1E, 0x65, 0x8A, 0x38, 0x2D, 0x64, 0xB1, 0xB8, 0x10, 0xA6, 0x16, 0x16, 0x0D, 0x1D,
    0x56, 0x41, 0xC7, 0x8B, 0x28, 0x94, 0x75, 0x6F, 0x1D, 0xC8, 0xF4, 0xC0, 0xAE, 0x30, 0xDC, 0x35,
    0xA8, 0xEB, 0xD2, 0x77, 0xEB, 0xCA, 0xBF, 0x50, 0xCB, 0xD9, 0xFB, 0x0A, 0xEA, 0x77, 0xC9, 0xB6,
    0x0B, 0x94, 0x57, 0x58, 0x3F, 0x53, 0xC8, 0xAE, 0x48, 0x6E, 0xAC, 0x59, 0x4D, 0x2E, 0x20, 0xB6,
    0x57, 0xC5, 0xB8, 0x23, 0x10, 0xAA, 0x29, 0xEF, 0xD8, 0x74, 0x20, 0xD8, 0xA3, 0x5F, 0x36, 0x6C,
    0x75, 0xEA, 0xA3, 0x68, 0x6A, 0x38, 0xFA, 0xB9, 0x42, 0xFE, 0x5D, 0x7E, 0xE5, 0x24, 0xE2, 0xB3,
    0x64, 0x2C, 0x14, 0x24, 0xE0, 0xA7, 0x7F, 0x98, 0xAC, 0x6F, 0xE1, 0x96, 0xB4, 0x66, 0xE4, 0xD8,
    0xCF, 0xB9, 0x90, 0xB3, 0xAA, 0x03, 0xBF, 0xD8, 0x42, 0x70, 0x3C, 0x43, 0x6A, 0x1E, 0x5F, 0x4B,
    0x1F, 0x23, 0x13, 0x75, 0x05, 0x47, 0x5D, 0xDF, 0xD1, 0x05, 0xD9, 0xCA, 0xE3, 0x8B, 0x4F, 0x96,
    0xCD, 0x0A, 0xBB, 0x70, 0x9D, 0xB6, 0xE6, 0x70, 0x51, 0xF5, 0x22, 0x01, 0x30, 0x2D, 0xDB, 0xE7,
    0x85, 0x3E, 0xC7, 0x85, 0xF3, 0x32, 0xAB, 0x9A, 0xC1, 0xCD, 0x78, 0xD4, 0xA9, 0x13, 0x80, 0x48,
    0xF1, 0x85, 0xD1, 0xCA, 0x1F, 0x15, 0x91, 0x2B, 0xBF, 0x39, 0x38, 0xFC, 0x01, 0x28, 0x8C, 0x51,
    0x5B, 0x72, 0xB4, 0x49, 0x5C, 0xA4, 0x7D, 0xEF, 0xEE, 0xCE, 0x86, 0xAA, 0x75, 0xDF, 0x46, 0x0D,
    0x7F, 0xB5, 0x1B, 0xC0, 0xDA, 0x52, 0x9E, 0x2C, 0x77, 0xED, 0x76, 0x8F, 0xB9, 0xBA, 0xEC, 0xA4,
    0xAC, 0x68, 0x20, 0xB3, 0xF7, 0xEF, 0x91, 0x3C, 0x61, 0xEB, 0x97, 0x97, 0x10, 0x4D, 0x4B, 0xE3,
    0x3D, 0xF5, 0xF5, 0x10, 0x82, 0x87, 0xF4, 0x74, 0x11, 0xB5, 0x2C, 0x66, 0xC4, 0xF0, 0xA8, 0x6A,
    0xE8, 0x0C, 0xA1, 0x15, 0xD6, 0x09, 0xDB, 0xEF, 0xA3, 0x9B, 0xFC, 0x16, 0x93, 0x02, 0x16, 0xE1,
    0x96, 0xCF, 0xEC, 0x59, 0xB8, 0xC5, 0xB0, 0xD5, 0xDB, 0x5B, 0xDC, 0x07, 0xB7, 0x6C, 0x4E, 0x9C,
    0xA1, 0xBE, 0x74, 0x93, 0xCD, 0x72, 0xAA, 0xDB, 0x73, 0xD4, 0x7D, 0xE8, 0xE5, 0x10, 0x84, 0xD1,
    0x10, 0xD3, 0x4A, 0x4E, 0x85, 0xC5, 0xDA, 0x77, 0x84, 0xEF, 0x92, 0xB9, 0x17, 0x52, 0x69, 0x72,
    0x2E, 0xBB, 0x9A, 0xFB, 0x06, 0x15, 0xB4, 0xAA, 0xBE, 0xE6, 0x6B, 0x3A, 0x90, 0xA5, 0xE6, 0xD3,
    0xC0, 0xD6, 0xAF, 0xCE, 0x2E, 0x82, 0x3A, 0xA0, 0x19, 0xFA, 0xC0, 0xE4, 0x53, 0x79, 0x2D, 0x90,
    0x14, 0x61, 0xEF, 0x67, 0x3B, 0xED, 0xD7, 0x8E, 0xC4, 0x8B, 0x45, 0x63, 0x64, 0x7C, 0xEF, 0xC1,
    0x4A, 0xEF, 0xAD, 0x3D, 0x75, 0x0C, 0x35, 0x19, 0x24, 0x44, 0xAD, 0xC4, 0x37, 0x17, 0xFA, 0xAC,
    0x70, 0xDA, 0x87, 0xD1, 0x93, 0xE7, 0xAC, 0xAA, 0x4F, 0x48, 0xAF, 0xA2, 0x10, 0x48, 0xC4, 0xD0,
    0x10, 0x99, 0x68, 0x13, 0x3E, 0x36, 0xA7, 0xC8, 0xA5, 0x3C, 0xAF, 0x11, 0x79, 0x14, 0x1C, 0xBD,
    0xE2, 0x78, 0x6F, 0x3A, 0x3E, 0xA1, 0xAB, 0x39, 0x01, 0x19, 0xD8, 0x55, 0x5F, 0x65, 0xBF, 0xF4,
    0xCB, 0x48, 0x6D, 0x3B, 0xFB, 0xDC, 0x35, 0xAB, 0xBD, 0x39, 0x30, 0x9D, 0x21, 0xAA, 0x2D, 0x15,
    0xE8, 0xFA, 0x40, 0xEA, 0x80, 0xFF, 0x88, 0x96, 0x17, 0x82, 0x75, 0xC0, 0xB0, 0xCE, 0x1F, 0xB2,
    0x7E, 0xBB, 0xBE, 0xF4, 0x16, 0xF1, 0x4C, 0x04, 0x4E, 0xCC, 0xE9, 0x4A, 0xE7, 0x5D, 0x7D, 0x26,
    0xD3, 0x2B, 0x9D, 0x51, 0xFB, 0x56, 0xF0, 0x2F, 0x36, 0x07, 0x38, 0x15, 0x0A, 0x61, 0x60, 0x55,
    0xC3, 0x4B, 0x93, 0x07, 0xA8, 0x64, 0x79, 0x50, 0x5A, 0x82, 0xAB, 0x70, 0x25, 0xB1, 0x75, 0x34,
    0x38, 0xF7, 0x52, 0xD9, 0x1D, 0xC0, 0xC8, 0x8D, 0x0A, 0xAD, 0x48, 0x64, 0x01, 0xEC, 0xF3, 0x8C,
    0x59, 0xC5, 0xB5, 0xF2, 0xC8, 0x86, 0x81, 0xAD, 0xB6, 0xAC, 0x88, 0x92, 0x9C, 0x3E, 0x43, 0x74,
    0xFB, 0xEA, 0xB8, 0x70, 0xD0, 0xB2, 0x25, 0x06, 0xA2, 0x88, 0x4B, 0x75, 0x22, 0xCC, 0x14, 0x81,
    0x53, 0x99, 0x18, 0x10, 0xD1, 0xF7, 0x01, 0xDE, 0x9B, 0x80, 0xFE, 0xD0, 0x56, 0x01, 0x66, 0xE3,
    0xAB, 0xF6, 0xCB, 0x1C, 0x37, 0xA2, 0x2A, 0x6F, 0xCF, 0xE9, 0xDF, 0x10, 0x7F, 0x09, 0x25, 0x98,
    0x49, 0xB4, 0x2B, 0x6B, 0xEB, 0x7B, 0xA6, 0x00, 0xE2, 0xBD, 0x22, 0xA1, 0xC6, 0xCF, 0x78, 0x6A,
    0xBF, 0x35, 0x7F, 0x5B, 0xBC, 0x88, 0x72, 0xE1, 0x09, 0x18, 0x48, 0x51, 0xFD, 0xBC, 0x2B, 0x46,
    0x13, 0xD4, 0x84, 0x27, 0x38, 0x38, 0x7B, 0xE9, 0x23, 0x38, 0x8A, 0x8B, 0x9A, 0x18, 0xB5, 0x82,
    0x0D, 0x0F, 0xC1, 0x39, 0x12, 0x61, 0x0A, 0x3A, 0xCA, 0xEF, 0xB6, 0x9A, 0x71, 0x75, 0x41, 0x34,
    0x18, 0x76, 0xA9, 0x89, 0x1D, 0xAA, 0x41, 0x8F, 0x07, 0x0F, 0x2F, 0x73, 0x64, 0xFA, 0xA1, 0x5C,
    0x93, 0x41, 0xB3, 0xB5, 0x49, 0x65, 0x23, 0x80, 0xEF, 0x42, 0x5C, 0x96, 0x90, 0x27, 0xB3, 0xE1,
    0xF1, 0x8D, 0x76, 0xF7, 0x41, 0x12, 0x0B, 0xD6, 0x2C, 0xBB, 0xC4, 0xD1, 0x93, 0x17, 0x37, 0x89,
    0xEF, 0xD0, 0x74, 0x0F, 0xA0, 0xCF, 0x41, 0x99, 0xEB, 0x30, 0xAA, 0x59, 0xCE, 0x41, 0xBD, 0x9D,
    0x59, 0x0C, 0x82, 0x64, 0x22, 0xAC, 0xF0, 0x22, 0xC0, 0xC7, 0xB3, 0xB7, 0x10, 0x00, 0x94, 0xE2,
    0x4E, 0xF5, 0x50, 0x06, 0x4D, 0x1A, 0xE8, 0xFA, 0xFE, 0x4C, 0xFA, 0xA3, 0xA9, 0x7E, 0x49, 0x04,
    0x7D, 0xDE, 0x45, 0xA4, 0xF7, 0x63, 0x23, 0x2A, 0x55, 0x8E, 0xDE, 0xD7, 0xB6, 0x6E, 0x92, 0xA4,
    0xE0, 0x28, 0x23, 0x62, 0x2C, 0x0E, 0xB6, 0x1A, 0xE5, 0xC5, 0x6D, 0x68, 0xBA, 0x0A, 0x92, 0xEA,
    0xA9, 0x9F, 0x56, 0xC9, 0x65, 0x3F, 0xDD, 0x37, 0x65, 0x9C, 0x1F, 0x76, 0x5B, 0xF7, 0xAA, 0x3B,
    0x57, 0x8C, 0x2A, 0xF5, 0x24, 0x9D, 0x9A, 0x28, 0x4D, 0x3B, 0xF2, 0xF4, 0xF8, 0x1D, 0x72, 0x30,
    0x46, 0xB0, 0x1C, 0x09, 0xD9, 0xD7, 0x12, 0xA2, 0xA1, 0x46, 0x2B, 0xF0, 0x00, 0x69, 0xFE, 0x95,
    0x56, 0xB6, 0xC3, 0xC7, 0x20, 0xB3, 0x52, 0x7F, 0xD3, 0xB2, 0xC2, 0x6B, 0x7E, 0x5B, 0xF6, 0xDC,
    0x80, 0x38, 0xC3, 0x07, 0x16, 0xC8, 0x22, 0x09, 0xCC, 0xCF, 0xB0, 0x52, 0x3E, 0xAB, 0x90, 0x83,
    0x32, 0x93, 0x9B, 0x1E, 0xC8, 0xC5, 0x8B, 0x80, 0xC1, 0x1E, 0x00, 0xF2, 0xEB, 0xA4, 0x46, 0xA1,
    0x21, 0xDE, 0xE4, 0x72, 0x99, 0x9A, 0x01, 0xCA, 0xA8, 0xC6, 0x7B, 0xAA, 0xB4, 0x9B, 0x1D, 0x59,
    0x3E, 0x83, 0x6C, 0x51, 0xDA, 0x19, 0x20, 0x15, 0x2C, 0x00, 0xB1, 0xD2, 0x72, 0x5E, 0x68, 0x2B,
    0x81, 0xD6, 0x33, 0x59, 0xED, 0xD5, 0x61, 0x91, 0xE9, 0x99, 0x13, 0xA2, 0x57, 0xE1, 0xF6, 0x61,
    0x4F, 0x1D, 0xCD, 0xDC, 0x61, 0xFD, 0xD5, 0x5C, 0xC9, 0xC7, 0x77, 0xE4, 0xC8, 0x09, 0x86, 0xFF,
    0x77, 0x65, 0x7D, 0x21, 0xD8, 0x0F, 0x1A, 0xA6, 0x48, 0xF6, 0x9B, 0x75, 0xAC, 0x88, 0xA6, 0xF8,
    0x93, 0xCC, 0x1B, 0x29, 0x31, 0xAA, 0x4B, 0x78, 0x51, 0x41, 0xBC, 0x47, 0x7A, 0x1E, 0xAB, 0xAA,
    0x31, 0x09, 0xAE, 0x24, 0x1C, 0x26, 0x45, 0xBD, 0x08, 0xAE, 0xB9, 0xE4, 0x89, 0xC4, 0x3B, 0xC1,
    0xD1, 0x0B, 0x55, 0x15, 0xE1, 0x0E, 0x74, 0xE9, 0x9E, 0x6D, 0x0B, 0x7D, 0x31, 0x01, 0x0C, 0x89,
    0x05, 0x3A, 0xCC, 0xE0, 0xAD, 0xB1, 0xF6, 0x86, 0x3B, 0x8E, 0x9C, 0x90, 0x61, 0x63, 0xBE, 0x31,
    0x25, 0xAB, 0x18, 0xC9, 0x3E, 0x1A, 0x3E, 0x85, 0xEF, 0x93, 0x66, 0xC8, 0x57, 0x95, 0xE3, 0x2B,
    0x65, 0x66, 0x1C, 0x96, 0x95, 0xC6, 0x60, 0x65, 0x76, 0xD0, 0x09, 0x9E, 0xE0, 0xC8, 0xED, 0x2B,
    0xDC, 0x69, 0x8C, 0x67, 0x24, 0xE8, 0x6A, 0x9E, 0x03, 0x05, 0xA5, 0x1C, 0x09, 0x11, 0x42, 0x36,
    0x1F, 0x09, 0x45, 0xA7, 0x6B, 0x55, 0x16, 0x8A, 0x15, 0x7C, 0x91, 0xB7, 0x9D, 0x6C, 0xF7, 0xCA,
    0x21, 0x49, 0xB0, 0xA4, 0x5D, 0xAD, 0xF2, 0x37, 0xBE, 0x97, 0x51, 0xAE, 0x1B, 0xBE, 0x29, 0x9E,
    0xBC, 0xC1, 0x17, 0x27, 0x2D, 0x21, 0x44, 0xB3, 0xC0, 0x93, 0x67, 0xA4, 0x1A, 0x20, 0x15, 0x5F,
    0x7C, 0x7C, 0xCB, 0x06, 0xB6, 0x89, 0x25, 0x24, 0xB5, 0xEA, 0xB2, 0xDE, 0x1A, 0xF1, 0xC4, 0xE5,
    0x68, 0xA4, 0xB6, 0xFF, 0x19, 0xEE, 0xFA, 0x58, 0x56, 0xBB, 0xFF, 0xA3, 0x81, 0xBB, 0x64, 0xD4,
    0xC7, 0x95, 0x6C, 0xF9, 0x43, 0x09, 0xF6, 0x3B, 0xA8, 0xBE, 0xFE, 0x4F, 0xB6, 0x93, 0x22, 0x80,
    0x09, 0x84, 0x5D, 0xC0, 0x8E, 0xC5, 0x3F, 0x67, 0x2D, 0x23, 0x22, 0x65, 0xDB, 0x4A, 0x31, 0x5C,
    0x37, 0x81, 0xE5, 0x95, 0x31, 0x86, 0x6D, 0xED, 0xB7, 0xD7, 0xBE, 0xCE, 0x83, 0x93, 0xD7, 0xFE,
    0x5A, 0x71, 0x09, 0xEA, 0xA8, 0x7B, 0xAD, 0xF3, 0x44, 0x61, 0xAF, 0xB3, 0xE1, 0xEF, 0xC4, 0x1C,
    0xE1, 0x65, 0xB7, 0xF6, 0x9A, 0x97, 0x07, 0xE6, 0x19, 0x70, 0xC0, 0x84, 0x49, 0x65, 0xCC, 0x4F,
    0x1F, 0x16, 0xC1, 0xA4, 0x86, 0xA3, 0xCF, 0x24, 0x3B, 0xBE, 0xB2, 0x0E, 0xD9, 0x9E, 0x99, 0xCA,
    0x8F, 0x3A, 0x09, 0xB1, 0x83, 0x30, 0xE6, 0x97, 0x92, 0x5A, 0x1C, 0x41, 0x46, 0x30, 0x81, 0x12,
    0xF2, 0xA7, 0x5C, 0x54, 0x6B, 0x1F, 0x94, 0x33, 0xAF, 0xD0, 0x85, 0xBE, 0x01, 0x5E, 0xE7, 0x93,
    0x4C, 0x52, 0x83, 0xB8, 0x10, 0x70, 0x83, 0xDE, 0x43, 0xC3, 0xCF, 0xA3, 0xE1, 0x0C, 0x87, 0xF7,
    0x95, 0x0A, 0xE4, 0xAF, 0x15, 0xB6, 0x4C, 0x25, 0xD7, 0xA6, 0x11, 0xE3, 0x3F, 0x43, 0x07, 0x20,
    0xD0, 0xD1, 0x96, 0xDD, 0xE2, 0xE8, 0xBA, 0x3B, 0xDB, 0x29, 0x52, 0x41, 0x29, 0x75, 0xE0, 0x97,
    0xB0, 0x3E, 0xCC, 0x9C, 0x97, 0x75, 0x10, 0x78, 0xA6, 0x36, 0xE1, 0x5B, 0xA1, 0x9B, 0x0F, 0x18,
    0x43, 0x59, 0xDE, 0xBD, 0x65, 0xA0, 0xCB, 0x79, 0xD0, 0x32, 0xEB, 0x9F, 0xDB, 0x83, 0xE6, 0x90,
    0x40, 0x9D, 0x81, 0xB6, 0xB8, 0xE6, 0x0F, 0x37, 0x92, 0x61, 0x1F, 0x2A, 0x56, 0xEB, 0x9D, 0x3B,
    0xE8, 0x60, 0xD1, 0x17, 0x6D, 0xCB, 0xD4, 0x3C, 0xE2, 0x4E, 0xEB, 0xCF, 0x15, 0xAC, 0x08, 0x27,
    0xA3, 0x6F, 0x99, 0xA2, 0x8C, 0x39, 0x9E, 0x51, 0x9C, 0xFB, 0xBC, 0xE4, 0x2D, 0x48, 0x72, 0x78,
    0x49, 0xCF, 0xC7, 0x8D, 0xD6, 0x70, 0xC0, 0xB3, 0x26, 0x1D, 0xEE, 0x40, 0xF4, 0xB2, 0xD3, 0x81,
    0xC1, 0x4B, 0x7F, 0xCA, 0x5C, 0xA1, 0xD8, 0x79, 0xC1, 0x99, 0x0E, 0x16, 0xBD, 0xFC, 0x67, 0x17,
    0x92, 0x97, 0x7A, 0x29, 0xE0, 0xE2, 0xF6, 0xC3, 0x5A, 0x8A, 0x9B, 0xFB, 0xE7, 0x2E, 0x87, 0x91,
    0xD1, 0x16, 0xD2, 0x51, 0x9F, 0x3E, 0xFD, 0x22, 0x01, 0xF1, 0x26, 0x3E, 0x2D, 0x32, 0x9E, 0x4E,
    0x68, 0xF2, 0xC8, 0x64, 0x11, 0xE2, 0x68, 0x66, 0xA4, 0xB0, 0xFB, 0x87, 0x57, 0xF5, 0x12, 0x32,
    0xFB, 0x46, 0xBA, 0xD8, 0xC5, 0x2D, 0xD6, 0xB9, 0x99, 0x58, 0xE2, 0x47, 0xFE, 0x6E, 0x5D, 0xE5,
    0x42, 0xE8, 0xA6, 0xB2, 0x2B, 0x07, 0xAA, 0x06, 0x70, 0x0F, 0xBC, 0xD1, 0xB7, 0xE8, 0x3A, 0x9F,
    0xC4, 0x2B, 0x2E, 0x45, 0xD0, 0x21, 0xF4, 0x38, 0x97, 0x47, 0x7E, 0xC6, 0x7A, 0x31, 0x4E, 0x04,
    0x29, 0xA8, 0x77, 0xC3, 0x65, 0x64, 0x79, 0x31, 0x6F, 0x4F, 0x4E, 0x77, 0xF3, 0xB1, 0x38, 0x9E,
    0x3E, 0x40, 0xA8, 0xAA, 0x7A, 0x17, 0xD0, 0x8D, 0x53, 0x40, 0x17, 0x93, 0x19, 0x4D, 0x2E, 0x26,
    0x89, 0xFE, 0x27, 0xC4, 0x2B, 0x99, 0x9E, 0x17, 0x21, 0x2C, 0xFE, 0xF4, 0x16, 0xE2, 0x45, 0x5F,
    0x13, 0x4A, 0xEF, 0x1B, 0xAC, 0xAE, 0x64, 0x30, 0x41, 0x6F, 0x2C, 0xC1, 0xF1, 0x09, 0x2D, 0xC4,
    0x1B, 0x3D, 0x8F, 0x6D, 0xA0, 0x42, 0x24, 0xC1, 0xC1, 0x39, 0x34, 0xE7, 0x50, 0xE8, 0xAD, 0x53,
    0x82, 0x06, 0x26, 0xA5, 0x99, 0xD1, 0x70, 0x38, 0x4B, 0xAD, 0x75, 0x2C, 0xF3, 0x55, 0xF1, 0x52,
    0xBB, 0x66, 0xA7, 0x3D, 0x81, 0xEC, 0x57, 0xEC, 0x1D, 0x67, 0xF0, 0x6C, 0xD3, 0xEC, 0xC9, 0xB9,
    0xD4, 0x40, 0xF7, 0xBE, 0xD4, 0x84, 0xDA, 0xF6, 0x6A, 0xEE, 0x1B, 0xD3, 0x9A, 0x69, 0x03, 0xBB,
    0x7C, 0xBE, 0xC9, 0x06, 0x9E, 0x53, 0xE1, 0x5F, 0xD1, 0xD5, 0x1A, 0x8B, 0x8C, 0x6D, 0xC7, 0xA2,
    0x44, 0xF4, 0x1D, 0x07, 0x5D, 0xE3, 0xD7, 0x89, 0xE7, 0xA5, 0x7D, 0x51, 0x2B, 0xFA, 0x11, 0x37,
    0xB2, 0xF5, 0xE3, 0xA2, 0xFA, 0x4A, 0xCA, 0x9C, 0x5A, 0xEF, 0xF8, 0x1B, 0xD0, 0x37, 0xBE, 0xC1,
    0x09, 0x04, 0xD5, 0x48, 0x41, 0xA1, 0x19, 0x64, 0x70, 0x08, 0xD8, 0x59, 0x5D, 0x1C, 0xCC, 0xBC,
    0x14, 0xED, 0x3D, 0xFA, 0xC7, 0x6E, 0xF3, 0x5F, 0x88, 0x1B, 0x2B, 0xCE, 0x83, 0x20, 0xAF, 0x6D,
    0xC1, 0x76, 0x6C, 0xD1, 0x0A, 0x36, 0xF4, 0x69, 0x89, 0x81, 0x06, 0x0F, 0x99, 0xC2, 0x46, 0x73,
    0x0B, 0x2E, 0x43, 0x1B, 0x21, 0xEA, 0xCA, 0x2E, 0x93, 0x1E, 0x94, 0x5A, 0xDF, 0xC1, 0xE3, 0x70,
    0xD4, 0x4E, 0xEA, 0x5F, 0xEE, 0x38, 0x0B, 0x7E, 0xDC, 0x23, 0x61, 0x9A, 0x55, 0x1B, 0x4B, 0x6E,
    0xB6, 0xB2, 0x4F, 0x30, 0x23, 0xE7, 0xA8, 0xC9, 0xBB, 0x45, 0xFF, 0x13, 0x13, 0x6F, 0x9E, 0x32,
    0x05, 0x62, 0xD4, 0x2B, 0xC9, 0x72, 0xBC, 0x03, 0x2D, 0x4A, 0xCD, 0x9A, 0xAC, 0xE8, 0xD1, 0xC8,
    0x31, 0x11, 0x05, 0x1D, 0x2E, 0xC0, 0xB7, 0xC0, 0x03, 0xBE, 0xB8, 0x13, 0x42, 0x70, 0x5C, 0x89,
    0xAE, 0xA9, 0xF6, 0xE1, 0x43, 0xC0, 0x96, 0x5C, 0x89, 0xCD, 0x2E, 0xB4, 0xAE, 0xE5, 0x36, 0xCA,
    0xC4, 0x31, 0x0D, 0x41, 0x62, 0xFB, 0x4E, 0x01, 0x9B, 0x54, 0x92, 0x22, 0x71, 0xBE, 0x86, 0xD1,
    0x1F, 0xF2, 0xD4, 0xBE, 0x16, 0xE3, 0xBE, 0xF2, 0x8E, 0xF5, 0xFB, 0xB7, 0xEC, 0x4B, 0x5C, 0x27,
    0xD0, 0x04, 0x65, 0xC2, 0x0C, 0xF5, 0xC4, 0x25, 0xFC, 0x13, 0xB5, 0x99, 0x55, 0x45, 0xBF, 0x54,
    0x7D, 0xCB, 0x79, 0x41, 0xAD, 0x61, 0xB9, 0x63, 0x5E, 0xAD, 0x20, 0xCD, 0xDA, 0x6B, 0x6C, 0x38,
    0x65, 0x06, 0x2B, 0x0B, 0x20, 0x9C, 0xAD, 0xB8, 0xDF, 0x36, 0x92, 0xE0, 0x46, 0xB6, 0xE2, 0x64,
    0xC0, 0x40, 0x55, 0xCD, 0xCA, 0x12, 0x7B, 0xB5, 0x19, 0xC1, 0x62, 0xF6, 0x6A, 0x87, 0x45, 0xFB,
    0x0B, 0x27, 0x4B, 0x1F, 0xE2, 0xA6, 0xE6, 0x12, 0x4D, 0xDC, 0xB6, 0x2B, 0xBA, 0x4D, 0xB0, 0xA1,
    0xA0, 0x78, 0xEB, 0xF9, 0x85, 0xF4, 0xB2, 0x7D, 0x98, 0x0E, 0xCC, 0x6F, 0x69, 0xD9, 0x1E, 0xE5,
    0x49, 0xC5, 0x1D, 0xB6, 0x32, 0xA2, 0x61, 0xB9, 0x58, 0x55, 0x7B, 0x1E, 0xFB, 0xA0, 0x83, 0xE0,
    0x27, 0x88, 0x1E, 0x12, 0x37, 0xD7, 0xAE, 0x48, 0xA7, 0x04, 0xE7, 0x52, 0x33, 0xDE, 0xC8, 0xBD,
    0x51, 0x21, 0xBA, 0xB3, 0xC5, 0x9D, 0x58, 0xBF, 0xD3, 0x7D, 0x65, 0x18, 0x3B, 0x28, 0xFB, 0x2B,
    0xD8, 0xDC, 0x18, 0x52, 0x9C, 0x48, 0x54, 0x4B, 0xEC, 0xFD, 0x86, 0x08, 0xA3, 0xC0, 0xF3, 0x0A,
    0x91, 0xDE, 0x72, 0xBC, 0x4D, 0xBE, 0x71, 0x7D, 0xB0, 0x5C, 0x51, 0x17, 0x60, 0x87, 0xAB, 0x37,
    0x9F, 0x47, 0xFF, 0x60, 0xE2, 0x98, 0xFC, 0x0C, 0xF7, 0xE4, 0x5F, 0xB0, 0x76, 0xF3, 0x98, 0x01,
    0x57, 0x30, 0xB8, 0xA2, 0xBF, 0xEC, 0xA2, 0x87, 0xFB, 0x98, 0x13, 0x75, 0x6C, 0x1C, 0xF5, 0xFE,
    0xD3, 0x6E, 0x47, 0x07, 0x3F, 0xA8, 0x6C, 0x80, 0xD6, 0x09, 0x46, 0x00, 0xF2, 0x8F, 0xC4, 0xC9,
    0xD2, 0xD5, 0x61, 0x0C, 0xFF, 0xEA, 0xA3, 0x2A, 0x52, 0x78, 0xA0, 0x19, 0x8B, 0x41, 0x36, 0x6D,
    0x77, 0xF1, 0xFB, 0xFE, 0x5A, 0x0D, 0x93, 0x49, 0x53, 0xD7, 0x1D, 0x26, 0x3F, 0x90, 0xA8, 0xFC,
    0x2F, 0xE8, 0x03, 0xE1, 0x06, 0xA7, 0xE7, 0x05, 0x9E, 0x18, 0x0B, 0x1A, 0xE6, 0x54, 0x32, 0x06,
    0xF1, 0xAC, 0x06, 0xC7, 0x72, 0xA8, 0x8E, 0x22, 0x61, 0x7F, 0xD6, 0xF4, 0xC6, 0x92, 0xA8, 0xBB,
    0xD5, 0x8A, 0x6B, 0x28, 0x2F, 0x6D, 0xA3, 0xDF, 0xC1, 0x6A, 0xB4, 0x8B, 0x19, 0x3F, 0x0B, 0x2F,
    0x37, 0x2C, 0xC3, 0xF6, 0x1C, 0xB7, 0x5C, 0x0C, 0x81, 0x9F, 0x34, 0xA2, 0xAF, 0x1C, 0xDA, 0x0C,
    0x4D, 0xEB, 0xD6, 0x07, 0x64, 0xB0, 0x37, 0x8D, 0xE1, 0x29, 0xA7, 0x55, 0xAC, 0x0F, 0x13, 0x11,
    0x8E, 0xD6, 0xFC, 0x1A, 0xFE, 0x38, 0x30, 0x69, 0x5F, 0x10, 0x4C, 0xF6, 0x38, 0xA9, 0x3F, 0xE4,
    0xBF, 0x75, 0x4B, 0x46, 0x56, 0x52, 0x54, 0x5A, 0xD3, 0x08, 0xC9, 0x7D, 0x25, 0x42, 0x1E, 0xCD,
    0x64, 0xE6, 0xF1, 0xC5, 0x13, 0x6F, 0x68, 0x28, 0x4C, 0x24, 0xE1, 0xCC, 0xBB, 0x27, 0x7C, 0xD4,
    0x25, 0x87, 0xD0, 0x4F, 0x5D, 0x93, 0x3C, 0xA2, 0xE6, 0x5C, 0x00, 0x89, 0xD2, 0x46, 0xF5, 0xEA,
    0x8E, 0xA1, 0xBB, 0x77, 0x32, 0xFD, 0xBF, 0x1F, 0x05, 0x96, 0xD3, 0x44, 0x2C, 0x07, 0x43, 0xC6,
    0x44, 0xC2, 0x8F, 0xBF, 0x50, 0xB1, 0xC3, 0xF5, 0xB7, 0xA0, 0x7A, 0x62, 0x9B, 0x67, 0x7A, 0x78,
    0x2D, 0xC3, 0xE2, 0x2F, 0x5A, 0x75, 0x0F, 0xD9, 0xA0, 0x98, 0x69, 0xAC, 0xDB, 0x4D, 0xED, 0x04,
    0x92, 0x87, 0xAF, 0xEC, 0x57, 0x43, 0xCA, 0x3D, 0xEA, 0x19, 0xAE, 0x6D, 0xA9, 0xBF, 0x99, 0x26,
    0x87, 0xA5, 0xE0, 0xEA, 0x53, 0x5B, 0x32, 0xD4, 0x57, 0x1B, 0x9C, 0x20, 0x30, 0x46, 0x39, 0x74,
    0x42, 0x47, 0x59, 0x29, 0x06, 0x85, 0xE3, 0xE3, 0x62, 0x08, 0x60, 0xD7, 0xC9, 0xD5, 0x8B, 0xB3,
    0x60, 0x7A, 0xD0, 0xE6, 0x8A, 0x4F, 0x28, 0x53, 0xC5, 0x4B, 0x38, 0xE5, 0x9A, 0xFF, 0xD0, 0xFF,
    0xB7, 0x14, 0x75, 0x7F, 0x43, 0x13, 0xA8, 0x6F, 0xFE, 0xEC, 0x56, 0x4A, 0xE0, 0x5B, 0x35, 0x78,
    0x73, 0x82, 0xFD, 0x2C, 0x97, 0x00, 0x54, 0x7B, 0x20, 0x94, 0xF7, 0xF0, 0xDA, 0xF5, 0x5A, 0x84,
    0x67, 0x99, 0xAA, 0x8F, 0x01, 0xE6, 0xA6, 0xF6, 0xC2, 0x65, 0x7D, 0x66, 0x70, 0x72, 0x06, 0xC3,
    0x0D, 0x67, 0x53, 0x81, 0x65, 0xC8, 0xF6, 0x5F, 0x7A, 0xAD, 0xED, 0x03, 0xC4, 0x55, 0x1E, 0xD9,
    0xD1, 0x41, 0x2B, 0x44, 0x3B, 0x35, 0xF4, 0x8D, 0xDA, 0x3B, 0x52, 0x22, 0xC8, 0x6C, 0xF2, 0xA4,
    0xA3, 0x5F, 0xA7, 0x4B, 0x48, 0x58, 0xDA, 0xA8, 0x82, 0x5B, 0x41, 0x76, 0x66, 0x2F, 0x8B, 0xA4,
    0x27, 0xAB, 0x55, 0x88, 0x94, 0xB7, 0x4A, 0xA9, 0xF9, 0x20, 0xF1, 0x5F, 0x43, 0x4E, 0xE2, 0x36,
    0x2A, 0x05, 0x59, 0x1A, 0x28, 0x61, 0xBF, 0x19, 0x46, 0x2F, 0x5D, 0x6D, 0x62, 0x7D, 0x57, 0xAB,
    0x0A, 0x5D, 0xAD, 0x42, 0x26, 0x70, 0x18, 0xCB, 0x3C, 0xF7, 0x09, 0xDC, 0x02, 0x55, 0xB4, 0x1F,
    0xF4, 0x54, 0x08, 0x0D, 0xDF, 0xEB, 0xEC, 0x6D, 0xA0, 0xDF, 0xE2, 0x60, 0xA6, 0x73, 0x65, 0xC3,
    0x22, 0xD3, 0x27, 0x26, 0x1A, 0x59, 0xC1, 0x39, 0x0F, 0xED, 0xC2, 0xE9, 0x49, 0xB6, 0x0D, 0xAB,
    0xF6, 0xBE, 0xFE, 0x07, 0x26, 0xE1, 0x24, 0x5A, 0x48, 0xF5, 0x77, 0x2E, 0x8A, 0x77, 0x10, 0x32,
    0xA0, 0x5E, 0x1D, 0x92, 0xB1, 0x1C, 0x85, 0x10, 0xA0, 0x82, 0x00, 0x5E, 0xA1, 0xE8, 0x12, 0x93,
    0x92, 0xB2, 0x40, 0x8F, 0x25, 0x34, 0x65, 0x42, 0x55, 0x48, 0xF6, 0x90, 0x69, 0xCB, 0x5B, 0xA5,
    0x73, 0xCA, 0xD3, 0xE9, 0xBE, 0x44, 0xF4, 0xD7, 0xBE, 0xD3, 0x76, 0x29, 0x37, 0xF6, 0xB6, 0x94,
    0xE3, 0x14, 0x07, 0x9A, 0x38, 0x83, 0xDA, 0xA7, 0xE8, 0xB8, 0x72, 0xC5, 0xF7, 0xDE, 0x86, 0xAE,
    0xE2, 0x6D, 0x2D, 0x6F, 0xD5, 0x3E, 0x94, 0xFA, 0x7E, 0x30, 0xE4, 0x5F, 0xFE, 0xEF, 0x2C, 0x7C,
    0xFE, 0xAD, 0xD0, 0xEC, 0x15, 0x11, 0xAD, 0x2C, 0x2C, 0xCF, 0x62, 0x27, 0xC8, 0xDE, 0xDE, 0xC9,
    0xCF, 0x11, 0xA4, 0xF8, 0xAF, 0xDA, 0xD5, 0x22, 0x2F, 0x4D, 0x10, 0xFE, 0xAF, 0x7D, 0xCD, 0x5D,
    0xE4, 0x8F, 0x3E, 0x36, 0x54, 0x94, 0x66, 0xE6, 0x77, 0xDD, 0x97, 0x5B, 0xB1, 0xF8, 0x27, 0x21,
    0x85, 0x4A, 0x80, 0x0D, 0xA1, 0x63, 0x4E, 0x13, 0x3D, 0x4A, 0x83, 0x2E, 0x89, 0x65, 0xD8, 0xC6,
    0x8E, 0xF7, 0xB7, 0x3F, 0x1E, 0x1B, 0xCB, 0x3C, 0x2C, 0x96, 0x52, 0x0D, 0x2D, 0x27, 0xB6, 0xEA,
    0xFA, 0x38, 0x09, 0xDE, 0x44, 0xBB, 0x27, 0x0F, 0x4C, 0x8A, 0x09, 0x5E, 0xE2, 0xF9, 0xB2, 0x3D,
    0x4F, 0xDE, 0x74, 0x6A, 0x4F, 0xCE, 0x56, 0x35, 0x25, 0xD5, 0x93, 0xFA, 0xB5, 0x94, 0xDE, 0x4C,
    0xF6, 0x10, 0x3F, 0xFE, 0xF4, 0x15, 0x70, 0x0E, 0x93, 0x5A, 0xD5, 0xCD, 0xD2, 0x9A, 0x34, 0x1C,
    0xAE, 0x67, 0x28, 0xB8, 0xE7, 0x72, 0x4B, 0xEB, 0x3E, 0x38, 0x7C, 0x8D, 0xE5, 0x72, 0xDC, 0xB6,
    0x65, 0x90, 0xB3, 0xFE, 0xB1, 0x43, 0xE7, 0x48, 0x64, 0xF3, 0x4E, 0xEF, 0xFF, 0x4F, 0x1F, 0xFF,
    0xF0, 0xF1, 0xB9, 0x48, 0x73, 0xE5, 0x2C, 0x81, 0xB8, 0x92, 0x05, 0xCA, 0x09, 0x8F, 0x0F, 0xAF,
    0x20, 0x4E, 0x46, 0xE8, 0x0C, 0xFD, 0x65, 0x08, 0xB5, 0x3B, 0x61, 0xE5, 0xD1, 0x94, 0x1A, 0x78,
    0x42, 0x75, 0xDC, 0xC0, 0xDF, 0x22, 0x84, 0x67, 0x3A, 0x4F, 0x85, 0x0F, 0x8B, 0x73, 0xE1, 0x4A,
    0xD3, 0x91, 0xCA, 0xA1, 0xA7, 0x8B, 0x00, 0x72, 0x07, 0x2F, 0x24, 0x59, 0xFC, 0x63, 0xE2, 0x11,
    0x58, 0xF8, 0x23, 0x69, 0x94, 0xEF, 0x74, 0x43, 0x72, 0x5C, 0x2D, 0xE5, 0xD2, 0x10, 0x18, 0x22,
    0x4C, 0x2A, 0x3D, 0x0D, 0x96, 0x89, 0x22, 0x01, 0x08, 0xB0, 0x31, 0x0D, 0xDC, 0x4E, 0xE5, 0x73,
    0xE2, 0xA2, 0x44, 0xF4, 0xA8, 0x6D, 0x51, 0x9A, 0x23, 0xA8, 0x62, 0x25, 0x90, 0x88, 0x31, 0xE1,
    0x84, 0xFE, 0x3C, 0x9A, 0xF4, 0xC7, 0xDD, 0xB3, 0xF2, 0x2D, 0x37, 0xF1, 0x00, 0x92, 0xFD, 0xFB,
    0x51, 0x6C, 0xB8, 0xBA, 0x71, 0xB2, 0x8C, 0xBC, 0xA3, 0xE2, 0x1F, 0x62, 0xFB, 0xE6, 0xA9, 0x67,
    0x92, 0xF7, 0x47, 0x66, 0x4A, 0x94, 0x05, 0xEF, 0xE9, 0x93, 0xE9, 0x27, 0x97, 0xBA, 0x5D, 0xA6,
    0x0A, 0x31, 0x27, 0x54, 0x21, 0x84, 0x70, 0xCD, 0x4A, 0x3B, 0x8D, 0x05, 0x13, 0x05, 0x2A, 0x6A,
    0x64, 0x49, 0xA3, 0x78, 0x74, 0xE1, 0x42, 0xBC, 0xFE, 0x47, 0x81,
];

const SAFESTART_RTP_0: [u8; 15] = [
    0x67, 0x42, 0xC0, 0x15, 0x8C, 0x8D, 0x40, 0xA0, 0xCB, 0xCF, 0x00, 0xF0, 0x88, 0x46, 0xA0,
];
const SAFESTART_RTP_1: [u8; 4] = [
    0x68, 0xCE, 0x3C, 0x80,
];
const SAFESTART_RTP_2: [u8; 908] = [
    0x65, 0xB8, 0x00, 0x04, 0x00, 0x00, 0x05, 0x39, 0x31, 0x40, 0x00, 0x40, 0xD2, 0x4E, 0x4E, 0x4E, 
    0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 
    0xBA, 0xEB, 0xAE, 0xBA, 0xEB, 0xAE, 0xBA, 0xEB, 0xAE, 0xBA, 0xEB, 0xAE, 0xBA, 0xEB, 0xAE, 0xBA, 
    0xFF, 0xFF, 0xE1, 0x05, 0xD8, 0xA0, 0x00, 0x20, 0x0B, 0xC2, 0x26, 0x64, 0xF0, 0x78, 0x1B, 0x1D, 
    0x4E, 0xA5, 0xC4, 0xA9, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAD, 0xAF, 0xFE, 0x3E, 0x70, 0x40, 
    0xBB, 0x01, 0x30, 0x70, 0xDF, 0xEE, 0xBE, 0x13, 0x2D, 0xE0, 0x79, 0x8A, 0xE7, 0xA7, 0xAE, 0xBA, 
    0xEB, 0xAE, 0xBA, 0xEB, 0xFF, 0x87, 0xFA, 0x05, 0x98, 0x1B, 0x35, 0x2D, 0xC0, 0x5B, 0x02, 0x82, 
    0x46, 0xD2, 0xFE, 0x2D, 0x72, 0x23, 0xA7, 0x1A, 0x31, 0xAD, 0xB6, 0xF6, 0xB6, 0xB6, 0xB6, 0xB6, 
    0xB6, 0xB6, 0xB6, 0xBF, 0xF0, 0xFF, 0x40, 0xB3, 0x01, 0x33, 0x74, 0xFC, 0xF8, 0xA9, 0xB0, 0xBD, 
    0xA3, 0x6F, 0x4F, 0xFF, 0xF8, 0x06, 0xC3, 0xB8, 0x04, 0xD6, 0xE2, 0x71, 0xF7, 0xBC, 0x3E, 0xF8, 
    0x1F, 0x30, 0x80, 0x9C, 0xA6, 0xF2, 0x6E, 0x16, 0x6E, 0x07, 0x4C, 0xE5, 0x9D, 0x5C, 0xA9, 0x6B, 
    0x6B, 0x6B, 0xFF, 0x8F, 0x58, 0x60, 0xBA, 0x09, 0x0E, 0xD2, 0x7E, 0xA9, 0x06, 0x80, 0x8E, 0x4D, 
    0x3C, 0x30, 0x3A, 0x67, 0x2C, 0x0B, 0xCB, 0xC8, 0x3E, 0x2B, 0xD7, 0x5D, 0x75, 0xD7, 0x5D, 0x75, 
    0xD7, 0x5D, 0x75, 0xD2, 0xC5, 0x3A, 0x62, 0x78, 0xFA, 0xEB, 0xFD, 0x2B, 0xB5, 0xB5, 0xB5, 0x8A, 
    0x7E, 0x8F, 0x7F, 0xE6, 0xA9, 0xEB, 0xAE, 0xBA, 0xEB, 0xAE, 0xBA, 0xEB, 0xAE, 0xBA, 0xEB, 0xA7, 
    0x75, 0xD7, 0x5D, 0x74, 0xF4, 0xF5, 0xD7, 0x5D, 0x75, 0xD7, 0x5D, 0x75, 0xD7, 0x5D, 0x75, 0xD3, 
    0xD7, 0x5D, 0x75, 0xD3, 0xD3, 0xD7, 0x5D, 0x75, 0xD7, 0x5D, 0x75, 0xD7, 0x5D, 0x75, 0xD7, 0x4F, 
    0x5D, 0x75, 0xD7, 0x4F, 0x4F, 0x5D, 0x75, 0xD7, 0x5D, 0x75, 0xD7, 0x5D, 0x75, 0xD7, 0x5D, 0x3D, 
    0x75, 0xD7, 0x5D, 0x3D, 0x3D, 0x75, 0xD7, 0x5D, 0x75, 0xD7, 0x5D, 0x75, 0xD7, 0x5D, 0x74, 0xF5, 
    0xD7, 0x5D, 0x74, 0xF4, 0xFF, 0xE3, 0x8E, 0xAF, 0xDF, 0x80, 0x0B, 0xB7, 0x71, 0xA2, 0xC4, 0xE6, 
    0xFE, 0xED, 0x9D, 0xC6, 0x9A, 0xAD, 0x97, 0x65, 0x0A, 0x7B, 0x28, 0x86, 0xEB, 0xFF, 0xF5, 0xFB, 
    0xEE, 0xBF, 0x1F, 0xBB, 0x90, 0xB5, 0x47, 0x1C, 0xD7, 0xF8, 0xFC, 0x02, 0xFA, 0x78, 0xE0, 0xF5, 
    0x86, 0x2D, 0x20, 0xBA, 0x80, 0x3F, 0xB4, 0xFA, 0x40, 0x76, 0x15, 0x93, 0x6E, 0xD4, 0xF7, 0x3C, 
    0x10, 0xD7, 0x1A, 0x29, 0x7A, 0xFF, 0x18, 0xC7, 0xFF, 0x4D, 0xF3, 0x33, 0x7F, 0xF1, 0xB5, 0x3F, 
    0xF4, 0xD8, 0xE1, 0xD4, 0xB1, 0x86, 0xBF, 0x46, 0xE7, 0x7F, 0xE3, 0xF8, 0xFE, 0xF8, 0x31, 0xEF, 
    0xBE, 0xA7, 0xEE, 0xFC, 0x77, 0x26, 0x36, 0x53, 0xB0, 0xDB, 0x0A, 0x75, 0xDD, 0xC3, 0xFE, 0x1E, 
    0x82, 0x8E, 0xD1, 0x6A, 0x3B, 0xBE, 0x53, 0x86, 0xE7, 0x7B, 0xF2, 0xCB, 0x71, 0xFF, 0xBB, 0xF5, 
    0xFE, 0x73, 0xFA, 0xBE, 0xDC, 0xEF, 0xFD, 0xFD, 0xBF, 0xFF, 0xBF, 0xFB, 0xE2, 0xAE, 0xF5, 0x20, 
    0xEC, 0xAC, 0x32, 0x2E, 0x53, 0x87, 0xF5, 0xB6, 0x1D, 0x75, 0x54, 0xEB, 0xEE, 0x82, 0x79, 0xEA, 
    0x6D, 0x49, 0x87, 0x8A, 0x9C, 0x60, 0x68, 0x1F, 0x57, 0x26, 0x07, 0xFE, 0x8A, 0xFF, 0x9A, 0xD6, 
    0xAF, 0x15, 0x55, 0x93, 0xE5, 0x6B, 0x75, 0x2F, 0xF1, 0xF8, 0x01, 0xAB, 0xF0, 0xF4, 0x69, 0xD7, 
    0x14, 0x06, 0x21, 0x77, 0xFE, 0x85, 0x01, 0xBF, 0x64, 0x85, 0xBF, 0xFF, 0x4E, 0xA2, 0xC6, 0xC8, 
    0x82, 0x8A, 0xC6, 0x2E, 0xAC, 0xAD, 0x52, 0xA2, 0x6F, 0xEF, 0xDB, 0x22, 0x55, 0x4A, 0x45, 0xEB, 
    0xF7, 0xFB, 0x65, 0xE4, 0xB1, 0x1E, 0xBC, 0x83, 0x73, 0x7F, 0x1F, 0x80, 0x37, 0x6A, 0x5F, 0x6B, 
    0x01, 0xB6, 0x6D, 0xAD, 0x78, 0x14, 0xDD, 0x75, 0xBE, 0xFF, 0xF7, 0xF8, 0xAD, 0x67, 0x77, 0x0D, 
    0x75, 0x36, 0x7F, 0xDF, 0xA0, 0x84, 0x67, 0x69, 0x50, 0x2E, 0x3E, 0x33, 0xFB, 0xF3, 0x03, 0x5F, 
    0xA1, 0x6C, 0xE5, 0x45, 0x52, 0x3B, 0x37, 0xDF, 0xE3, 0xF0, 0xD2, 0xD4, 0x63, 0xB9, 0x3D, 0xC8, 
    0x73, 0x66, 0x52, 0xE2, 0xF4, 0x6E, 0xFC, 0x31, 0xE4, 0x17, 0xB1, 0xFF, 0xFF, 0xEC, 0x3A, 0x65, 
    0x1B, 0x71, 0xBA, 0xDA, 0xE9, 0x98, 0xEE, 0xE6, 0x35, 0xE5, 0xEF, 0xE6, 0x9F, 0xFB, 0x8D, 0xDD, 
    0x5A, 0xDF, 0xFF, 0x40, 0x9B, 0xBF, 0x9A, 0x37, 0x6F, 0xFF, 0x98, 0xE0, 0xAF, 0xDB, 0xDF, 0x15, 
    0x53, 0x8C, 0x4A, 0x8E, 0xA6, 0x28, 0xAB, 0x26, 0x3D, 0x5B, 0x31, 0x2B, 0xB6, 0x2C, 0x30, 0xAE, 
    0x21, 0x47, 0x7D, 0xD8, 0x8B, 0xA6, 0x68, 0x2E, 0x52, 0x8A, 0xA3, 0xDF, 0x57, 0xF6, 0x8C, 0x6E, 
    0x1E, 0x6A, 0xC3, 0x94, 0xB3, 0xDD, 0xD7, 0x6F, 0xF1, 0xF8, 0x01, 0xF7, 0x0B, 0xEB, 0x5C, 0xDD, 
    0x6F, 0x15, 0xA5, 0x38, 0xBF, 0x9C, 0x66, 0xB7, 0xA9, 0xC7, 0x2B, 0x98, 0xBC, 0x68, 0x88, 0x24, 
    0xFB, 0x9D, 0xB3, 0xFD, 0xB9, 0x9C, 0x16, 0xDF, 0x5E, 0x5A, 0x1C, 0xBF, 0xF9, 0x9F, 0x4B, 0x8D, 
    0xC1, 0x22, 0x29, 0x7F, 0x8E, 0xC0, 0x10, 0xE6, 0xA0, 0x24, 0x15, 0x07, 0x57, 0x29, 0xBB, 0x00, 
    0x31, 0x5C, 0xB2, 0xBF, 0xDD, 0x85, 0x8B, 0xEC, 0xA1, 0x7E, 0xF8, 0x10, 0xF1, 0x67, 0xE1, 0x4F, 
    0xF1, 0xE6, 0x6C, 0xA3, 0x8D, 0x56, 0xFE, 0x29, 0x4B, 0x55, 0xC7, 0xDD, 0x02, 0x6E, 0xFF, 0x0D, 
    0x1B, 0xB7, 0xFF, 0xCF, 0x8C, 0x5F, 0xFB, 0xE1, 0x5F, 0x77, 0xA6, 0xBE, 0xBC, 0x3B, 0x9B, 0x49, 
    0xC7, 0xB1, 0x9A, 0xDF, 0xD0, 0xE3, 0x94, 0x65, 0x15, 0x7D, 0x3B, 0x3E, 0x76, 0xF4, 0x2A, 0xD8, 
    0xD0, 0xD9, 0x6A, 0xDF, 0x7F, 0xED, 0xA6, 0x91, 0xDD, 0xDC, 0x6B, 0xC9, 0xC1, 0xFF, 0xDA, 0xBF, 
    0xE3, 0xB0, 0x04, 0x52, 0x6D, 0x36, 0x83, 0xAB, 0x9E, 0x10, 0x9C, 0x66, 0x5F, 0xBE, 0x36, 0x7B, 
    0xF9, 0xBF, 0xFE, 0xBE, 0x1F, 0xF3, 0xC0, 0x18, 0x77, 0xD0, 0x5B, 0x4E, 0x01, 0xC2, 0x12, 0x47, 
    0xB8, 0xAB, 0xC3, 0xB6, 0xD0, 0x9C, 0x03, 0x2C, 0xEB, 0x7B, 0x5B, 0x5B, 0x5F, 0xC3, 0xE3, 0xCA, 
    0xC1, 0x77, 0x22, 0x08, 0x2E, 0x82, 0x8B, 0xBE, 0x2A, 0xD1, 0x61, 0x70, 0x0C, 0xB0, 0x55, 0x53, 
    0x0F, 0x27, 0xFF, 0xFF, 0xE1, 0xEE, 0x28, 0x00, 0x08, 0x06, 0xEF, 0x15, 0xBE, 0xFB, 0xEF, 0xBE, 
    0xFB, 0xEF, 0xBE, 0xFB, 0xED, 0x6D, 0x6D, 0x6D, 0x6D, 0x6D, 0x6F, 0xC0, 
];
const SAFESTART_RTP_3: [u8; 16] = [
    0x61, 0xE0, 0x0, 0x40, 0x0, 0xBE, 0x40, 0x53, 0x80, 0xCF, 0xE4, 0xEA, 0xE3, 0x4E, 0xF0, 0xAC,
];
const SAFESTART_RTP_4: [u8; 13] = [
    0x61, 0xE0, 0x0, 0x80, 0x01, 0x3E, 0x40, 0xEE, 0x03, 0x70, 0xEF, 0x0A, 0xC0, 
];
const SAFESTART_RTP_5: [u8; 429] = [
    0x61, 0xE0, 0x00, 0xC0, 0x01, 0xBE, 0x40, 0x8E, 0x0A, 0xFA, 0xD2, 0xAF, 0x5A, 0xFA, 0xD7, 0xD6, 
    0xBE, 0xB5, 0xF5, 0xAF, 0xAD, 0x7D, 0x6B, 0xEB, 0x55, 0xCD, 0x8E, 0xC3, 0xE0, 0x98, 0xAF, 0x11, 
    0xE2, 0x3C, 0x47, 0x88, 0xEF, 0xAD, 0x45, 0x70, 0x45, 0x46, 0x37, 0x1D, 0xFB, 0xE0, 0xA3, 0x22, 
    0xBB, 0x1D, 0x83, 0x77, 0x30, 0xB0, 0x82, 0xD7, 0x41, 0x20, 0xBE, 0x21, 0x71, 0x0B, 0x88, 0x5F, 
    0x82, 0x48, 0x24, 0xDB, 0xDD, 0xF4, 0x7A, 0xCE, 0xF1, 0xA7, 0xDE, 0x3D, 0xCD, 0xC6, 0x3A, 0xB5, 
    0xBD, 0xF1, 0xAB, 0x6C, 0x42, 0xE2, 0x17, 0x10, 0xB8, 0xF7, 0x6C, 0x75, 0x10, 0xFF, 0x8D, 0x5C, 
    0xAA, 0xB9, 0x3B, 0xC6, 0x9F, 0x94, 0xEB, 0x9D, 0xF3, 0xBC, 0x69, 0xF9, 0x4F, 0xE7, 0x7C, 0xEF, 
    0x1A, 0x7E, 0x53, 0xF9, 0xDF, 0x3B, 0xC6, 0x9F, 0x94, 0xFE, 0x77, 0xCE, 0xF6, 0x2B, 0xC4, 0x78, 
    0x8F, 0x11, 0xE2, 0x3C, 0x47, 0x88, 0xF1, 0x1E, 0x23, 0xC4, 0x79, 0xF9, 0x4F, 0xE7, 0x7C, 0xEF, 
    0xF1, 0x9E, 0x34, 0xF0, 0xD7, 0x00, 0x03, 0xA0, 0x1A, 0x64, 0x1B, 0x87, 0xE3, 0x05, 0x89, 0xAF, 
    0x79, 0xF7, 0xF8, 0xCF, 0x1D, 0x1F, 0xFB, 0x58, 0x0C, 0xA0, 0x81, 0xC4, 0xF1, 0x8E, 0x42, 0x6C, 
    0x0B, 0xF6, 0x59, 0x43, 0x07, 0xFC, 0x67, 0x80, 0x87, 0xC1, 0x3E, 0xD3, 0xE3, 0xC2, 0x29, 0xAB, 
    0x01, 0xDA, 0xCC, 0x02, 0x0F, 0x88, 0x5A, 0x87, 0xFC, 0x4B, 0x18, 0x20, 0x5F, 0xF8, 0xCE, 0xB7, 
    0x6D, 0x0B, 0xE6, 0x22, 0x1A, 0x44, 0xE1, 0x83, 0x07, 0x52, 0x75, 0x47, 0xDE, 0x10, 0x4D, 0x7C, 
    0x18, 0xFE, 0x3B, 0x88, 0x36, 0x8F, 0xA9, 0xBF, 0x1D, 0x2E, 0xDC, 0x18, 0x0E, 0x94, 0x43, 0xFC, 
    0x77, 0x04, 0x2D, 0x44, 0x9E, 0x41, 0xC2, 0x3E, 0x2C, 0x61, 0x40, 0x10, 0x0A, 0x80, 0x5A, 0x40, 
    0x83, 0x02, 0x7F, 0x84, 0x3B, 0x46, 0x08, 0x23, 0x6C, 0xE6, 0x62, 0x0A, 0x68, 0x9E, 0x18, 0x43, 
    0x46, 0x8D, 0x05, 0x43, 0xFC, 0x7F, 0x43, 0x08, 0xF8, 0xEF, 0x5E, 0x63, 0xC7, 0x4B, 0x44, 0x8A, 
    0x59, 0x16, 0x66, 0xB6, 0xAC, 0xFF, 0x19, 0xD5, 0x06, 0xB5, 0x16, 0xE2, 0x1D, 0x4B, 0xC3, 0xE7, 
    0x90, 0x40, 0x1A, 0xBC, 0x77, 0xDB, 0x00, 0xF6, 0xF9, 0xFB, 0x03, 0xFB, 0xC3, 0xFF, 0xC6, 0x71, 
    0x96, 0x49, 0x10, 0x85, 0x68, 0xA1, 0xD2, 0xA5, 0x45, 0xD3, 0xD1, 0x30, 0xDF, 0xC2, 0x11, 0x59, 
    0xC4, 0x87, 0xF8, 0xCE, 0x6C, 0xE0, 0xEE, 0x84, 0xB0, 0xC4, 0xEC, 0x0C, 0x86, 0x21, 0x8F, 0xA0, 
    0xC0, 0xFB, 0x03, 0xA1, 0x9E, 0xA0, 0x7B, 0x64, 0x7A, 0x7F, 0x89, 0xE4, 0xC8, 0x18, 0x03, 0x98, 
    0xB0, 0xA2, 0xFC, 0xFF, 0xC1, 0x47, 0x8C, 0x92, 0xB5, 0xAD, 0x0E, 0x24, 0x97, 0x10, 0xB8, 0x85, 
    0xC4, 0x2E, 0x21, 0x7E, 0x6B, 0x1C, 0x91, 0xCE, 0xFF, 0x19, 0xDD, 0xF7, 0x77, 0x77, 0x77, 0x77, 
    0x78, 0x8F, 0x11, 0xE2, 0x3C, 0x47, 0x88, 0xF1, 0x1E, 0x23, 0xC4, 0x78, 0x8F, 0x11, 0xE2, 0x3C, 
    0x47, 0x88, 0x5C, 0x42, 0xE2, 0x17, 0x10, 0xB8, 0x85, 0xC4, 0x2E, 0x23, 0xC0, 
];
const SAFESTART_RTP_6: [u8; 141] = [
    0x61, 0xE0, 0x01, 0x00, 0x02, 0x3E, 0x42, 0xE0, 0xD3, 0xAD, 0x50, 0xA7, 0xC4, 0x71, 0x3C, 0x44, 
    0xC4, 0x8C, 0x4B, 0x31, 0x23, 0x12, 0xE2, 0x15, 0xE2, 0x17, 0x10, 0xB8, 0x85, 0xC4, 0x2E, 0x21, 
    0x71, 0x0B, 0x88, 0x58, 0xD3, 0xF9, 0xFC, 0xFE, 0x7F, 0x3F, 0x9F, 0xCF, 0xE7, 0xF1, 0x0B, 0x8F, 
    0x78, 0x93, 0x8F, 0xAB, 0xAB, 0xBD, 0xE2, 0xCF, 0xE7, 0xF3, 0xF9, 0xFC, 0xFE, 0x7F, 0x3F, 0x9F, 
    0xCF, 0xE3, 0xDE, 0xBE, 0xC7, 0x63, 0x8B, 0x3F, 0x9F, 0xCF, 0xE7, 0xF3, 0xF9, 0xFC, 0xFE, 0x7F, 
    0x3F, 0x9D, 0xE2, 0xCF, 0xE7, 0xF3, 0xF9, 0xFC, 0xFE, 0x7F, 0x3F, 0x9F, 0xCF, 0xE7, 0x78, 0xB3, 
    0xF9, 0xFC, 0xFE, 0x7F, 0x3F, 0x9F, 0xCF, 0xE7, 0xF3, 0xF9, 0xDE, 0x2C, 0xFE, 0x7F, 0x3F, 0x9F, 
    0xCF, 0xE7, 0xF3, 0xF9, 0xFC, 0xFE, 0x77, 0x84, 0xCF, 0xD0, 0x51, 0x40, 0x75, 0x35, 0x2D, 0xFF, 
    0x9C, 0xD1, 0xCD, 0x67, 0x34, 0x73, 0x51, 0x0B, 0x88, 0x5C, 0x42, 0xC2, 0xF0,  
];
const SAFESTART_RTP_7: [u8; 511] = [
    0x61, 0xE0, 0x01, 0x40, 0x02, 0xBE, 0x41, 0x78, 0x2B, 0xE0, 0x93, 0x15, 0xDC, 0x56, 0xCC, 0x3E, 
    0xB9, 0x8F, 0xAB, 0x1F, 0x56, 0x3E, 0xAC, 0x7D, 0x58, 0xFA, 0xB1, 0xF5, 0x63, 0xEA, 0xC5, 0x70, 
    0x49, 0x87, 0xA0, 0x5B, 0x58, 0xE2, 0x51, 0x15, 0xC1, 0x16, 0x26, 0x4B, 0x16, 0xB5, 0x07, 0x15, 
    0xD2, 0x4B, 0x49, 0x2F, 0xFD, 0x7D, 0xB6, 0xF8, 0x85, 0xC4, 0x2E, 0x21, 0x71, 0x0B, 0x88, 0x5C, 
    0x42, 0xE2, 0x17, 0xE0, 0x96, 0x26, 0x48, 0xC4, 0xBA, 0x0C, 0x8A, 0x38, 0xBE, 0x5C, 0x21, 0xE5, 
    0x1A, 0xFE, 0xA9, 0x97, 0xAA, 0x65, 0xEA, 0x99, 0x7A, 0xA6, 0x5E, 0x08, 0xEC, 0x1B, 0x06, 0xEE, 
    0x76, 0x61, 0x1C, 0x21, 0x7E, 0x7A, 0xF9, 0xD8, 0x9D, 0x89, 0x04, 0xF8, 0x6D, 0xD7, 0xD8, 0xEC, 
    0x7F, 0x63, 0xB1, 0xC4, 0x5C, 0x42, 0x7F, 0x81, 0xED, 0x5C, 0x87, 0xB5, 0x70, 0x71, 0xF9, 0x82, 
    0xEE, 0xDF, 0xBD, 0xFE, 0xF7, 0xEA, 0x38, 0xFC, 0xC7, 0x78, 0xE3, 0xF3, 0x1D, 0xE3, 0x8F, 0xCC, 
    0x77, 0x8E, 0x3F, 0x31, 0xDE, 0xB8, 0xCF, 0x04, 0x0F, 0x94, 0x6D, 0x2A, 0xE7, 0xA3, 0x97, 0x62, 
    0xB4, 0xCB, 0x75, 0xD9, 0xFA, 0xDC, 0x40, 0xAB, 0xFE, 0x33, 0xAD, 0x00, 0x10, 0x67, 0xC1, 0xF8, 
    0x3C, 0xC5, 0xC5, 0x9B, 0x31, 0xE3, 0xED, 0x22, 0x5F, 0xC7, 0xEF, 0x3F, 0x08, 0x68, 0x1F, 0xF2, 
    0x84, 0x35, 0x2C, 0x1E, 0xFB, 0xFC, 0x67, 0x49, 0x06, 0x05, 0x35, 0x70, 0x7B, 0x8E, 0x27, 0x7F, 
    0x3B, 0xF8, 0x86, 0x46, 0xFF, 0x4F, 0xCD, 0x62, 0x4A, 0x76, 0x0A, 0xCF, 0x3B, 0x60, 0x73, 0x48, 
    0x30, 0x5F, 0xC6, 0x7D, 0x05, 0x47, 0x8A, 0x79, 0x15, 0xA5, 0xEE, 0x94, 0x90, 0x4E, 0x57, 0x95, 
    0xD6, 0x01, 0x8F, 0xD6, 0xE5, 0xBE, 0xB3, 0x9A, 0x03, 0xE3, 0xFF, 0xE3, 0x3B, 0x52, 0x82, 0x0F, 
    0xAE, 0xE7, 0x88, 0xFF, 0x25, 0xDE, 0xAA, 0x60, 0xB7, 0x01, 0x7F, 0x65, 0x56, 0x05, 0x8B, 0xFE, 
    0x62, 0xD8, 0x07, 0x15, 0xFD, 0x01, 0xFF, 0x91, 0x7F, 0xE1, 0x1E, 0x11, 0x60, 0xB7, 0x56, 0x03, 
    0x14, 0x86, 0x97, 0x7E, 0x90, 0x5F, 0x7E, 0x27, 0xC4, 0x35, 0x5C, 0x75, 0x6C, 0x2A, 0xDD, 0xF8, 
    0x7D, 0xFF, 0x2F, 0xFF, 0x19, 0xC0, 0x95, 0xAE, 0xC3, 0x77, 0xD5, 0x4B, 0x3F, 0xE9, 0xC1, 0xBF, 
    0xF3, 0x7C, 0xA0, 0x2F, 0xEE, 0x03, 0x7A, 0x34, 0xBB, 0x68, 0xFE, 0x6D, 0x7E, 0x0B, 0x17, 0xE4, 
    0x36, 0x34, 0xF8, 0xAB, 0xAF, 0xAF, 0xF8, 0xCE, 0x30, 0x3F, 0x76, 0x3E, 0x3F, 0xD1, 0x51, 0xC2, 
    0x16, 0x47, 0xF8, 0xEF, 0xF3, 0x5E, 0x26, 0xE5, 0xFE, 0xB9, 0xCF, 0x7F, 0x75, 0x76, 0xF0, 0x0E, 
    0xDF, 0xCB, 0xF9, 0xF8, 0x95, 0x1C, 0x6E, 0xFF, 0xFC, 0x67, 0x46, 0x82, 0xD8, 0x69, 0xC7, 0x76, 
    0x32, 0x03, 0xC5, 0xDA, 0x3D, 0x15, 0xF5, 0x5A, 0x5B, 0xE7, 0xF3, 0x7E, 0xBE, 0x13, 0xCE, 0x84, 
    0xBF, 0x8C, 0xE5, 0x98, 0x25, 0x7C, 0x0D, 0x70, 0x38, 0x8D, 0xB8, 0x76, 0x59, 0x4B, 0xBE, 0x9C, 
    0xCF, 0x68, 0x0F, 0xF4, 0x1E, 0xE4, 0x5E, 0xC9, 0x0F, 0x81, 0x9F, 0x3F, 0xE3, 0x3A, 0xC3, 0x96, 
    0x27, 0x82, 0x26, 0xC0, 0xF6, 0x60, 0x25, 0x7B, 0xC0, 0x97, 0xEE, 0x5F, 0xD8, 0xF5, 0xA8, 0xC3, 
    0x4A, 0xF9, 0x6F, 0x1F, 0xCC, 0x5D, 0x83, 0x75, 0xFE, 0x27, 0xD1, 0xE5, 0xD7, 0xF7, 0x10, 0x4E, 
    0xBE, 0xB8, 0x63, 0x2A, 0xF2, 0xD3, 0x03, 0xBC, 0xD0, 0x1D, 0xD3, 0x44, 0xC7, 0xC5, 0x73, 0x88, 
    0x1C, 0x20, 0xB3, 0x2C, 0xFE, 0xC2, 0x61, 0x44, 0x2E, 0x21, 0x71, 0x0B, 0xF0, 0x5B, 0x06, 0xBA, 
    0x67, 0x2A, 0xE9, 0x9F, 0x03, 0xB4, 0xD0, 0x1D, 0xA6, 0x8C, 0xC0, 0x28, 0x21, 0x78, 0x8F, 
];
const SAFESTART_RTP_8: [u8; 73] = [
    0x61, 0xE0, 0x01, 0x80, 0x03, 0x3E, 0x40, 0xBE, 0x0D, 0x39, 0xF9, 0x8F, 0xB6, 0xDB, 0x4D, 0x0C, 
    0x08, 0x28, 0xAF, 0x88, 0xB4, 0x07, 0x11, 0x59, 0x61, 0xC4, 0x56, 0x5F, 0xB6, 0x2A, 0xF8, 0x85, 
    0x84, 0xCF, 0xC5, 0xE9, 0x6B, 0x10, 0xB8, 0x85, 0xAE, 0x09, 0xED, 0xDB, 0xB7, 0x6F, 0xA9, 0x4F, 
    0xC2, 0x87, 0xE1, 0x43, 0xF0, 0xA1, 0xF8, 0x50, 0xFC, 0x3E, 0x10, 0x5D, 0xCE, 0x92, 0x5B, 0x09, 
    0x85, 0x18, 0xB4, 0xAA, 0x21, 0x71, 0x0B, 0x0B, 0xC0, 
];
const SAFESTART_RTP_9: [u8; 35] = [
    0x61, 0xE0, 0x01, 0xC0, 0x03, 0xBE, 0x40, 0x47, 0x81, 0xC8, 0x7B, 0x93, 0xCA, 0x0F, 0x50, 0x3B, 
    0xC1, 0xEA, 0x0F, 0x7F, 0x85, 0x0E, 0xF0, 0xA1, 0xDE, 0x14, 0x3B, 0xC2, 0x87, 0x78, 0x4C, 0xFC, 
    0xE7, 0x78, 0x56, 
];
const SAFESTART_RTP_10: [u8; 173] = [
    0x61, 0xE0, 0x02, 0x00, 0x04, 0x3E, 0x40, 0x5F, 0xF8, 0xCB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 0xBB, 
    0xBB, 0xBC, 0x4F, 0x89, 0xF1, 0x3E, 0x27, 0xC4, 0xF8, 0x9F, 0x13, 0xE2, 0x7C, 0x4F, 0x89, 0xF1, 
    0x3E, 0x27, 0xC4, 0xF8, 0x9F, 0x13, 0xE2, 0x7C, 0x4F, 0x89, 0xF1, 0x3E, 0x7F, 0x3F, 0x9F, 0xCF, 
    0xE7, 0xF3, 0xF9, 0xFC, 0xFE, 0x7F, 0x3F, 0x9F, 0xCF, 0xE7, 0xF3, 0xF9, 0xFC, 0xFE, 0x7F, 0x3F, 
    0x9F, 0xCF, 0xE7, 0xF3, 0xF1, 0x87, 0x7C, 0xFE, 0x7F, 0x3F, 0x9F, 0xCF, 0xE7, 0xF3, 0xF9, 0xF8, 
    0x4C, 0xFE, 0x7F, 0x10, 0xB0, 0x91, 0xFC, 0xFE, 0x7E, 0x2F, 0x89, 0xB6, 0x65, 0x2D, 0xB9, 0x4B, 
    0x6E, 0x52, 0xDB, 0x94, 0x9C, 0xFE, 0x7F, 0x3F, 0x16, 0x3D, 0xD8, 0xD3, 0xEB, 0x52, 0xBE, 0x57, 
    0xCE, 0x7F, 0x3F, 0x9F, 0x8B, 0x3B, 0xB1, 0x9C, 0xFE, 0x7F, 0x3F, 0x16, 0x77, 0x63, 0x39, 0xFC, 
    0xFE, 0x7E, 0x53, 0xF3, 0x1D, 0xD8, 0xC2, 0x67, 0xE2, 0x38, 0xCB, 0xBB, 0xBB, 0xDE, 0xEE, 0xEE, 
    0xF7, 0xF8, 0x8A, 0xAE, 0xAB, 0xC4, 0x78, 0x8F, 0x11, 0xE2, 0x3C, 0x47, 0x88, 0xF1, 0x1E, 0x23, 
    0xC4, 0x78, 0x8F, 0x11, 0xE2, 0x17, 0x10, 0xB8, 0x85, 0xC4, 0x2E, 0x21, 0x6E, 
];

const FRAGMENT_SIZE: usize = 1400;

/// Prepends the already encoded SAFESTART_VIDEO to the encoded_str
fn prepend_safe_video(encoded_str: &[u8]) -> Vec<u8> {
    let mut new_vid = SAFESTART_VIDEO.to_vec();
    new_vid.extend(encoded_str);

    new_vid
}

/// Save the encoded stream to an MP4 file
pub fn save_mp4_file(
    mp4_filename: String,
    width: i32,
    height: i32,
    is_mp4_fragment: bool,
    is_hevc: bool,
    encoded_str: &Vec<u8>,
) {
    println!("   Writing MP4 output: {}", mp4_filename);

    // NOTE: AFL++ integration has issues with Mp4Muxer, so this has to be commented out to work with it
    let mut mp4muxer = Mp4Muxer::new(File::create(mp4_filename).unwrap());
    let enable_fragmentation = is_mp4_fragment;
    let is_hevc = is_hevc;
    mp4muxer.init_video(width, height, is_hevc, enable_fragmentation);
    mp4muxer.write_video(encoded_str);
    mp4muxer.close();
}

// Save encoded stream to RTP dump
pub fn save_rtp_file(
    rtp_filename: String,
    rtp_nal: &Vec<Vec<u8>>,
    is_safestart: bool
) {
    println!("   Writing RTP output: {}", rtp_filename);

    // Stage 1: NAL to packet (single packet mode for now)
    
    let mut packets: Vec<Vec<u8>> = Vec::new();
    let mut rtp_nal_mod: Vec<Vec<u8>> = Vec::new();
    let mut seq_num: u16 = 0x1234;
    let mut timestamp: u32 = 0x11223344;
    let ssrc:u32 = 0x77777777;
    if is_safestart {
        rtp_nal_mod.push(SAFESTART_RTP_0.to_vec());
        rtp_nal_mod.push(SAFESTART_RTP_1.to_vec());
        rtp_nal_mod.push(SAFESTART_RTP_2.to_vec());
        rtp_nal_mod.push(SAFESTART_RTP_3.to_vec());
        rtp_nal_mod.push(SAFESTART_RTP_4.to_vec());
        rtp_nal_mod.push(SAFESTART_RTP_5.to_vec());
        rtp_nal_mod.push(SAFESTART_RTP_6.to_vec());
        rtp_nal_mod.push(SAFESTART_RTP_7.to_vec());
        rtp_nal_mod.push(SAFESTART_RTP_8.to_vec());
        rtp_nal_mod.push(SAFESTART_RTP_9.to_vec());
        rtp_nal_mod.push(SAFESTART_RTP_10.to_vec());
    }
    
    rtp_nal_mod.extend(rtp_nal.clone());
    for i in 0..rtp_nal_mod.len() {

        let header_byte = 0x80; // version 2, no padding, no extensions, no CSRC, marker = false;
	let nal_type = rtp_nal_mod[i][0] & 0x1f;

        packets.push(Vec::new());
	packets[i].push(header_byte);
	let mut payload_type = 104; // common H264
	if nal_type == 5 {
	    payload_type = payload_type + 0x80; // add marker
	}
	if nal_type == 1 {
	    payload_type = payload_type + 0x80; // add marker
	    timestamp += 3000;
	}
        if nal_type == 28 {
	    if nal_type == 5 {
	        payload_type = payload_type + 0x80; // add marker
	    }
	    if nal_type == 1 {
	        payload_type = payload_type + 0x80; // add marker
	        if (rtp_nal_mod[i][1] & 0x80) != 0{
	            timestamp += 3000;
	        }
	    }
	}
	packets[i].push(payload_type);
	packets[i].extend(seq_num.to_be_bytes());
	seq_num += 1;
	packets[i].extend(timestamp.to_be_bytes());	
	packets[i].extend(ssrc.to_be_bytes());
	packets[i].extend(rtp_nal_mod[i].clone());
    }
    
    let mut out_bytes: Vec<u8> = Vec::new();
    let s = "#!rtpplay1.0 127.0.0.1/48888\n";
    let header = s.bytes();
    out_bytes.extend(header);
    
    let start_sec:u32 = 0;
    let start_usec:u32 = 0;
    let source:u32 = 0;
    let port:u16 = 0;
    let padding:u16 = 0;

    out_bytes.extend(start_sec.to_be_bytes());
    out_bytes.extend(start_usec.to_be_bytes());
    out_bytes.extend(source.to_be_bytes());
    out_bytes.extend(port.to_be_bytes());
    out_bytes.extend(padding.to_be_bytes());

    for i in 0..packets.len() {
    
        let plen:u16 = packets[i].len().try_into().unwrap();
        let blen:u16 = plen + 8;
        let ts:u32 = 0;
        
        out_bytes.extend(blen.to_be_bytes());      
        out_bytes.extend(plen.to_be_bytes());
        out_bytes.extend(ts.to_be_bytes()); 
        out_bytes.extend(packets[i].clone());
    }
    
    let mut f = match File::create(rtp_filename.clone()) {
        Err(_) => panic!("couldn't open {}", rtp_filename.clone()),
        Ok(file) => file,
    };

    match f.write_all(out_bytes.as_slice()) {
        Err(_) => panic!("couldn't write to file {}", rtp_filename.clone()),
        Ok(()) => (),
    };
    
}

/// Save the encoded stream as .264, AVCC, MP4 or RTP
pub fn save_encoded_stream(
    encoded_str: Vec<u8>,
    avcc_encoding: AVCCFormat,
    filename: &str,
    width: i32,
    height: i32,
    mp4_out: bool,
    is_mp4_fragment: bool,
    is_hevc: bool,
    avcc_out: bool,
    enable_safestart: bool,
    rtp_nal: Vec<Vec<u8>>,
) {
    println!("   Writing to {}", filename);
    let mut f = match File::create(filename) {
        Err(_) => panic!("couldn't open {}", filename),
        Ok(file) => file,
    };

    match f.write_all(encoded_str.as_slice()) {
        Err(_) => panic!("couldn't write to file {}", filename),
        Ok(()) => (),
    };

    if enable_safestart {
        println!("   Adding safestart video at the start of the video");
        let mut safestart_filename: String = filename.to_owned();
        safestart_filename.push_str(".safestart.264");

        let safestart_encoded_str = prepend_safe_video(&encoded_str);

        println!("   Writing to {}", safestart_filename);
        let mut f = match File::create(&safestart_filename) {
            Err(_) => panic!("couldn't open {}", safestart_filename),
            Ok(file) => file,
        };

        match f.write_all(safestart_encoded_str.as_slice()) {
            Err(_) => panic!("couldn't write to file {}", safestart_filename),
            Ok(()) => (),
        };

        // save the safestart MP4
        if mp4_out {
            let mut mp4_filename: String = filename.to_owned();
            mp4_filename.push_str(".safestart.mp4");
            save_mp4_file(
                mp4_filename,
                SAFESTART_VIDEO_WIDTH,
                SAFESTART_VIDEO_HEIGHT,
                is_mp4_fragment,
                false,
                &safestart_encoded_str,
            );
        }
    }

    if avcc_out {
        let avcc_extradata = encode_avcc_extradata(&avcc_encoding);
        let avcc_data = encode_avcc_data(avcc_encoding.nalus);

        let mut avcc_extradata_filename: String = filename.to_owned();
        avcc_extradata_filename.push_str(".avcc.js");

        let mut avcc_data_filename: String = filename.to_owned();
        avcc_data_filename.push_str(".avcc.264");

        println!(
            "   Writing AVCC file output: \n\t Extradata: {}\n\t AVCC Data: {}",
            avcc_extradata_filename, avcc_data_filename
        );
        println!("   NOTE: AVCC data may not be playable (e.g. SPS or PPS IDs non-incrementing)");

        let hex_avcc_extradata =
            avcc_extradata
                .iter()
                .enumerate()
                .fold(String::new(), |mut acc, (i, _)| {
                    if i < (avcc_extradata.len() - 1) {
                        acc.push_str(&format!("0x{}, ", hex::encode(vec![avcc_extradata[i]])))
                    } else {
                        acc.push_str(&format!("0x{}", hex::encode(vec![avcc_extradata[i]])))
                    }

                    if i % 16 == 0 && i != 0 {
                        acc.push_str("\n\t\t")
                    }
                    acc
                });

        // var allows us to overwrite if dynamically loading in the browser
        let complete_string = format!(
            "var avcC = new Uint8Array(\n\t[\n\t\t{}\n]);",
            hex_avcc_extradata
        );

        let mut avcc_f_ed = match File::create(&avcc_extradata_filename) {
            Err(_) => panic!("couldn't open {}", avcc_extradata_filename),
            Ok(file) => file,
        };

        match avcc_f_ed.write_all(complete_string.as_bytes()) {
            Err(_) => panic!("couldn't write to file {}", avcc_extradata_filename),
            Ok(()) => (),
        };

        let mut avcc_f_d = match File::create(&avcc_data_filename) {
            Err(_) => panic!("couldn't open {}", avcc_data_filename),
            Ok(file) => file,
        };

        match avcc_f_d.write_all(avcc_data.as_slice()) {
            Err(_) => panic!("couldn't write to file {}", avcc_data_filename),
            Ok(()) => (),
        };
    }

    if mp4_out {
        let mut mp4_filename: String = filename.to_owned();
        mp4_filename.push_str(".mp4");
        save_mp4_file(
            mp4_filename,
            width,
            height,
            is_mp4_fragment,
            is_hevc,
            &encoded_str,
        );
    }
    
    // save RTP dump
    if rtp_nal.len() > 0 {
        println!("Writing RTP dump");
	let mut rtp_filename: String = filename.to_owned();
        rtp_filename.push_str(".rtpdump");
        save_rtp_file(rtp_filename, &rtp_nal, enable_safestart);
    }
}

/// Given a H264 Decoded Stream object, reencode it and write it to a file
pub fn reencode_syntax_elements(
    ds: &mut H264DecodedStream,
    cut_nalu: i32,
    avcc_out: bool,
    silent_mode: bool,
    rtp_out: bool
) -> (Vec<u8>, AVCCFormat, Vec<Vec<u8>>) {
    let mut encoded_video: Vec<u8> = Vec::new();

    let mut sps_idx = 0;
    let mut subset_sps_idx = 0;
    let mut sps_extension_idx = 0;
    let mut pps_idx = 0;
    let mut prefix_nalu_idx = 0;
    let mut slice_idx = 0;
    let mut sei_idx = 0;
    let mut aud_idx = 0;

    // AVCC encoding elements
    let mut avcc_encoding = AVCCFormat::new();
    // RTP NAL units
    let mut rtp_nal: Vec<Vec<u8>> = Vec::new();
    
    if avcc_out {
        avcc_encoding.initial_sps = ds.spses[0].clone();
    }

    debug!(target: "encode","Encoding {} NALUs", ds.nalu_elements.len());

    for i in 0..ds.nalu_elements.len() {
        let mut encoded_str: Vec<u8> = Vec::new();
        let mut curr_nal: Vec<u8> = Vec::new();

        debug!(target: "encode","");
        debug!(target: "encode","Annex B NALU w/ {} startcode, len {}, forbidden_bit {}, nal_reference_idc {}, nal_unit_type {}",
            { if ds.nalu_elements[i].longstartcode {"long" } else {"short"} }, ds.nalu_elements[i].content.len(), ds.nalu_headers[i].forbidden_zero_bit, ds.nalu_headers[i].nal_ref_idc, ds.nalu_headers[i].nal_unit_type);

        if ds.nalu_elements[i].longstartcode {
            encoded_str.push(0);
            encoded_str.push(0);
            encoded_str.push(0);
            encoded_str.push(1);
        } else {
            encoded_str.push(0);
            encoded_str.push(0);
            encoded_str.push(1);
        }
        
        if rtp_out {
            println!("type {}", ds.nalu_headers[i].nal_unit_type);
            let mut rtp_bytes: Vec<u8> = Vec::new();
            let mut header:u8 = ds.nalu_headers[i].nal_unit_type;
            let (forbidden, _overflow) = ds.nalu_headers[i].forbidden_zero_bit.overflowing_shl(7);
            header = header | forbidden | (ds.nalu_headers[i].nal_ref_idc << 5);
            rtp_bytes.push(header);
            curr_nal.extend(rtp_bytes);      
        }

        let encoded_header = encode_nalu_header(&ds.nalu_headers[i]);
        encoded_str.extend(encoded_header.iter());

        match ds.nalu_headers[i].nal_unit_type {
            0 => {
                if !silent_mode {
                    println!("\t reencode_syntax_elements - NALU {} - Unknown nal_unit_type of 0 - not affecting encoding process", i);
                }
                encoded_str.extend(&ds.nalu_elements[i].content[1..]);
                if rtp_out {
                    curr_nal.extend(&ds.nalu_elements[i].content[1..]);
                }
            }
            1 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Coded slice of a non-IDR picture",
                        i
                    );
                }

                let associated_pps_id = ds.slices[slice_idx].sh.pic_parameter_set_id;

                let mut cur_pps_wrapper: Option<&PicParameterSet> = None;
                // retrieve the corresponding PPS
                // we search in reverse to get the most recent; ID collision is possible with random video generation
                // we use pps_idx to ensure only already encoded PPS's are used
                for i in (0..pps_idx).rev() {
                    if ds.ppses[i].pic_parameter_set_id == associated_pps_id {
                        cur_pps_wrapper = Some(&ds.ppses[i]);
                        break;
                    }
                }

                let cur_pps: &PicParameterSet;
                match cur_pps_wrapper {
                    Some(x) => cur_pps = x,
                    _ => panic!("reencode_syntax_elements - Associated SPS not found for PPS - associated_sps_idx : {}", associated_pps_id),
                }

                let associated_sps_id = cur_pps.seq_parameter_set_id;
                let mut cur_sps_wrapper: Option<&SeqParameterSet> = None;

                // we search in reverse to get the most recent; ID collision is possible with random video generation
                // we use sps_idx to ensure only already encoded SPS's are used
                if cur_pps.is_subset_pps {
                    // try subset sps
                    for i in (0..subset_sps_idx).rev() {
                        if ds.subset_spses[i].sps.seq_parameter_set_id == associated_sps_id {
                            cur_sps_wrapper = Some(&ds.subset_spses[i].sps);
                            break;
                        }
                    }
                } else {
                    for i in (0..sps_idx).rev() {
                        if ds.spses[i].seq_parameter_set_id == associated_sps_id {
                            cur_sps_wrapper = Some(&ds.spses[i]);
                            break;
                        }
                    }
                }
                
                let cur_sps: &SeqParameterSet;
                match cur_sps_wrapper {
                    Some(x) => {
                        cur_sps = x;
                    },
                    None => panic!("reencode_syntax_elements - Associated SPS not found for PPS - associated_sps_idx : {}", associated_sps_id),
                }
                let mut vp = VideoParameters::new(&ds.nalu_headers[i], cur_pps, cur_sps);
                // for neighbor macroblock processing
                vp.mbaff_frame_flag = ds.slices[slice_idx].sh.mbaff_frame_flag;

                let res = insert_emulation_three_byte(&encode_slice(
                    &ds.nalu_headers[i],
                    &ds.slices[slice_idx],
                    cur_sps,
                    cur_pps,
                    &vp,
                    silent_mode,
                ));

                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(&res);

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }

                encoded_str.extend(res.clone());
                
                if rtp_out {
                    curr_nal.extend(res);
                }
                slice_idx += 1;

                // We know that the following works:
                //encoded_str.extend(&ds.nalu_elements[i].content[1..]);
            }
            2 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Coded slice data partition A",
                        i
                    );
                }
                // TODO: Coded slice data partition A encoding. For now, just append nalu elements
                encoded_str.extend(&ds.nalu_elements[i].content[1..]);
                
                if rtp_out {
                    curr_nal.extend(&ds.nalu_elements[i].content[1..]);
                }

                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(&ds.nalu_elements[i].content[1..]);

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }
            }
            3 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Coded slice data partition B",
                        i
                    );
                }
                // TODO: Coded slice data partition B encoding. For now, just append nalu elements
                encoded_str.extend(&ds.nalu_elements[i].content[1..]);
                
                if rtp_out {
                    curr_nal.extend(&ds.nalu_elements[i].content[1..]);
                }
                
                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(&ds.nalu_elements[i].content[1..]);

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }
            }
            4 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Coded slice data partition C",
                        i
                    );
                }
                // TODO: Coded slice data partition C encoding. For now, just append nalu elements
                encoded_str.extend(&ds.nalu_elements[i].content[1..]);
                
                if rtp_out {
                    curr_nal.extend(&ds.nalu_elements[i].content[1..]);
                }

                
                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(&ds.nalu_elements[i].content[1..]);

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }
            }
            5 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Coded slice of an IDR picture",
                        i
                    );
                }

                let associated_pps_id = ds.slices[slice_idx].sh.pic_parameter_set_id;

                let mut cur_pps_wrapper: Option<&PicParameterSet> = None;
                // retrieve the corresponding PPS
                // we search in reverse to get the most recent; ID collision is possible with random video generation
                // we use pps_idx to ensure only already encoded PPS's are used
                for i in (0..pps_idx).rev() {
                    if ds.ppses[i].pic_parameter_set_id == associated_pps_id {
                        cur_pps_wrapper = Some(&ds.ppses[i]);
                        break;
                    }
                }

                let cur_pps: &PicParameterSet;
                match cur_pps_wrapper {
                    Some(x) => cur_pps = x,
                    _ => panic!("reencode_syntax_elements - Associated SPS not found for PPS - associated_sps_idx : {}", associated_pps_id),
                }

                let associated_sps_id = cur_pps.seq_parameter_set_id;
                let mut cur_sps_wrapper: Option<&SeqParameterSet> = None;

                // we search in reverse to get the most recent; ID collision is possible with random video generation
                // we use sps_idx to ensure only already encoded SPS's are used
                if cur_pps.is_subset_pps {
                    // try subset sps
                    for i in (0..subset_sps_idx).rev() {
                        if ds.subset_spses[i].sps.seq_parameter_set_id == associated_sps_id {
                            cur_sps_wrapper = Some(&ds.subset_spses[i].sps);
                            break;
                        }
                    }
                } else {
                    for i in (0..sps_idx).rev() {
                        if ds.spses[i].seq_parameter_set_id == associated_sps_id {
                            cur_sps_wrapper = Some(&ds.spses[i]);
                            break;
                        }
                    }
                }

                let cur_sps: &SeqParameterSet;
                match cur_sps_wrapper {
                    Some(x) => {
                        cur_sps = x;
                    },
                    None => panic!("reencode_syntax_elements - Associated SPS not found for PPS - associated_sps_idx : {}", associated_sps_id),
                }
                let mut vp = VideoParameters::new(&ds.nalu_headers[i], cur_pps, cur_sps);
                vp.mbaff_frame_flag = ds.slices[slice_idx].sh.mbaff_frame_flag;

                let res = insert_emulation_three_byte(&encode_slice(
                    &ds.nalu_headers[i],
                    &ds.slices[slice_idx],
                    cur_sps,
                    cur_pps,
                    &vp,
                    silent_mode,
                ));

                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(&res);

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }

                encoded_str.extend(res.clone());
                
                if rtp_out {
                    curr_nal.extend(res);
                }
                
                slice_idx += 1;
            }
            6 => {
                if !silent_mode {
                    println!("\t reencode_syntax_elements - NALU {} - Supplemental enhancement information", i);
                }
                // only pass in already encoded SPSes
                let res = encode_sei_message(&ds.seis[sei_idx], &ds.spses[0..sps_idx], silent_mode);

                if res.len() == 0 {
                    debug!(target: "encode","[WARNING] SEI Encoded Payload is empty - copying over NALU bytes");
                    encoded_str.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));
                    
                    
                    if rtp_out {
                        curr_nal.extend(insert_emulation_three_byte(
                            &ds.nalu_elements[i].content[1..],
                        ));
                    }
                    
                    
                } else {
                    encoded_str.extend(insert_emulation_three_byte(&res));
                    
                    if rtp_out {
                        curr_nal.extend(insert_emulation_three_byte(&res));
                    }
                
                }

                if avcc_out {
                    let mut cur_encoded_sei = encoded_header.clone();
                    if res.len() == 0 {
                        debug!(target: "encode","[WARNING] SEI Encoded Payload is empty - copying over NALU bytes");
                        cur_encoded_sei.extend(insert_emulation_three_byte(
                            &ds.nalu_elements[i].content[1..],
                        ));
                    } else {
                        cur_encoded_sei.extend(insert_emulation_three_byte(&res));
                    }

                    avcc_encoding.nalus.push(cur_encoded_sei);
                }
                sei_idx += 1;
            }
            7 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Encoding Sequence Parameter Set",
                        i
                    );
                }
                let res = insert_emulation_three_byte(&encode_sps(&ds.spses[sps_idx], false));
                if avcc_out {
                    let mut cur_encoded_sps = encoded_header.clone();
                    cur_encoded_sps.extend(&res);

                    avcc_encoding.sps_list.push(cur_encoded_sps);
                }

                encoded_str.extend(res.clone());
                
                if rtp_out {
                    curr_nal.extend(res);
                }
                
                sps_idx += 1;
            }
            8 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Encoding Picture Parameter Set",
                        i
                    );
                }

                let mut cur_sps_wrapper: Option<&SeqParameterSet> = None;
                if pps_idx < ds.ppses.len() {
                    let associated_sps_id = ds.ppses[pps_idx].seq_parameter_set_id;
                    if ds.ppses[pps_idx].is_subset_pps {
                        // try subset sps
                        for i in (0..subset_sps_idx).rev() {
                            if ds.subset_spses[i].sps.seq_parameter_set_id == associated_sps_id {
                                cur_sps_wrapper = Some(&ds.subset_spses[i].sps);
                                break;
                            }
                        }
                    } else {
                        // we search in reverse to get the most recent; ID collision is possible with random video generation
                        for i in (0..sps_idx).rev() {
                            if ds.spses[i].seq_parameter_set_id == associated_sps_id {
                                cur_sps_wrapper = Some(&ds.spses[i]);
                                break;
                            }
                        }
                    }

                    let cur_sps: &SeqParameterSet;
                    match cur_sps_wrapper {
                        Some(x) => {
                            cur_sps = x;
                            let res =
                                insert_emulation_three_byte(&encode_pps(&ds.ppses[pps_idx], cur_sps));

                            if avcc_out {
                                let mut cur_encoded_pps = encoded_header.clone();
                                cur_encoded_pps.extend(&res);

                                avcc_encoding.pps_list.push(cur_encoded_pps);
                            }

                            encoded_str.extend(res.clone());
                            if rtp_out {
                                curr_nal.extend(res);
                            }
                            pps_idx += 1;
                        }
                        _ => {
                            // TODO: We could consider not panicking and continuing with a default SPS (e.g., LRU)
                            panic!(
                                    "reencode_syntax_elements - SPS or SubsetSPS with id {} not found",
                                    associated_sps_id
                                )   
                        }
                    }
                }
            }
            9 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Access unit delimiter",
                        i
                    );
                }

                let res =
                    insert_emulation_three_byte(&encode_access_unit_delimiter(&ds.auds[aud_idx]));

                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(&res);

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }
                encoded_str.extend(res.clone());
                
                if rtp_out {
                    curr_nal.extend(res);
                }
                
                aud_idx += 1;
            }
            10 => {
                if !silent_mode {
                    println!("\t reencode_syntax_elements - NALU {} - End of Sequence", i);
                }
                // According to 7.3.2.5 there is nothing to parse
                // According to 7.4.2.5 this signals that the next NALU shall be an IDR
                if ds.nalu_elements[i].content.len() > 1 {
                    encoded_str.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));
                    
                if rtp_out {
                    curr_nal.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));
                    
                }
                    
                    if avcc_out {
                        let mut cur_encoded_slice = encoded_header.clone();
                        cur_encoded_slice.extend(insert_emulation_three_byte(
                            &ds.nalu_elements[i].content[1..],
                        ));
                        avcc_encoding.nalus.push(cur_encoded_slice);
                    }
                }
            }
            11 => {
                if !silent_mode {
                    println!("\t reencode_syntax_elements - NALU {} - End of Stream", i);
                }
                // According to 7.3.2.6 there is nothing to parse
                // According to 7.4.2.6 this signals that there is nothing else to decode, so we could just `break;`
                if ds.nalu_elements[i].content.len() > 1 {
                    encoded_str.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));
                    
                    if rtp_out {
                        curr_nal.extend(insert_emulation_three_byte(
                            &ds.nalu_elements[i].content[1..],
                        ));
                    }
                    
                    if avcc_out {
                        let mut cur_encoded_slice = encoded_header.clone();
                        cur_encoded_slice.extend(insert_emulation_three_byte(
                            &ds.nalu_elements[i].content[1..],
                        ));
                        avcc_encoding.nalus.push(cur_encoded_slice);
                    }
                }
            }
            12 => {
                if !silent_mode {
                    println!("\t reencode_syntax_elements - NALU {} - Filler Data", i);
                }
                // According to 7.3.2.7 and 7.4.2.7 this is, as the name describes, filler data
                // that should be all 0xff bytes
                // TODO: implement 7.3.2.7
                //filler_data_rbsp();
                encoded_str.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                ));
                
                if rtp_out {
                    curr_nal.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));
                }
                
                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }
            }
            13 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Sequence parameter set extension",
                        i
                    );
                }
                let res = insert_emulation_three_byte(&encode_sps_extension(
                    &ds.sps_extensions[sps_extension_idx],
                ));
                if avcc_out {
                    let mut cur_encoded_sps = encoded_header.clone();
                    cur_encoded_sps.extend(&res);

                    avcc_encoding.sps_list.push(cur_encoded_sps);
                }
                
                encoded_str.extend(res.clone());
                
                if rtp_out {
                    curr_nal.extend(res);
                }
                
                sps_extension_idx += 1;
            }
            14 => {
                if !silent_mode {
                    println!("\t reencode_syntax_elements - NALU {} - Prefix NAL unit", i);
                }

                if ds.nalu_headers[i].svc_extension_flag {
                    let res = insert_emulation_three_byte(&encode_prefix_nal_unit_svc(
                        &ds.nalu_headers[i],
                        &ds.prefix_nalus[prefix_nalu_idx],
                    ));

                    if avcc_out {
                        let mut cur_encoded_slice = encoded_header.clone();
                        cur_encoded_slice.extend(&res);

                        avcc_encoding.nalus.push(cur_encoded_slice);
                    }
                    encoded_str.extend(res.clone());
                    
                    if rtp_out {
                        curr_nal.extend(res);
                    }

                    prefix_nalu_idx += 1;
                }
                //encoded_str.extend(insert_emulation_three_byte(&ds.nalu_elements[i].content[1..]));
            }
            15 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Subset sequence parameter set",
                        i
                    );
                }
                let res = insert_emulation_three_byte(&encode_subset_sps(
                    &ds.subset_spses[subset_sps_idx],
                ));
                if avcc_out {
                    let mut cur_encoded_sps = encoded_header.clone();
                    cur_encoded_sps.extend(&res);

                    avcc_encoding.sps_list.push(cur_encoded_sps);
                }
                encoded_str.extend(res.clone());
                
                if rtp_out {
                    curr_nal.extend(res);
                }
                
                subset_sps_idx += 1;
                //encoded_str.extend(insert_emulation_three_byte(ds.nalu_elements[i].content[1..]));
            }
            16 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Depth parameter set",
                        i
                    );
                }
                // TODO: depth_parameter_set_rbsp();
                encoded_str.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                ));
                
                
                if rtp_out {
                    curr_nal.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));
                }
                
                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }
            }
            17..=18 => {
                if !silent_mode {
                    println!("\t reencode_syntax_elements - NALU {} - RESERVED nal_unit_type of {} - Copying Bytes", i, ds.nalu_headers[i].nal_unit_type);
                }
                // Ignore for now
                encoded_str.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                ));
                
                if rtp_out {
                    curr_nal.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                    ));
                }
                
                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }
            }
            19 => {
                if !silent_mode {
                    println!("\t reencode_syntax_elements - NALU {} - Coded slice of an auxiliary coded picture without partitioning", i);
                }
                // TODO: slice_layer_without_partitioning_rbsp(); // but non-VCL
                encoded_str.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                ));
                
               if rtp_out {
                    curr_nal.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                    ));
                }
                
                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }
            }
            20 => {
                if !silent_mode {
                    println!(
                        "\t reencode_syntax_elements - NALU {} - Coded slice extension",
                        i
                    );
                }
                let associated_pps_id = ds.slices[slice_idx].sh.pic_parameter_set_id;

                let mut cur_pps_wrapper: Option<&PicParameterSet> = None;
                // retrieve the corresponding PPS
                // we search in reverse to get the most recent; ID collision is possible with random video generation
                for i in (0..pps_idx).rev() {
                    if ds.ppses[i].pic_parameter_set_id == associated_pps_id && ds.ppses[i].is_subset_pps {
                        cur_pps_wrapper = Some(&ds.ppses[i]);
                        break;
                    }
                }

                let cur_pps: &PicParameterSet;
                match cur_pps_wrapper {
                    Some(x) => cur_pps = x,
                    _ =>  panic!("reencode_syntax_elements - Associated PPS not found for coded slice extension - associated_pps_idx : {}", associated_pps_id),
                }

                let associated_sps_id = cur_pps.seq_parameter_set_id;
                let mut cur_subset_sps_wrapper: Option<&SubsetSPS> = None;

                // we search in reverse to get the most recent; ID collision is possible with random video generation
                // we use sps_idx to ensure only already encoded SPS's are used
                for i in (0..subset_sps_idx).rev() {
                    if ds.subset_spses[i].sps.seq_parameter_set_id == associated_sps_id {
                        cur_subset_sps_wrapper = Some(&ds.subset_spses[i]);
                        break;
                    }
                }

                let cur_subset_sps: &SubsetSPS;
                match cur_subset_sps_wrapper {
                    Some(x) => {
                        cur_subset_sps = x;
                    },
                    None => panic!("reencode_syntax_elements - Associated Subset SPS not found for PPS - associated_sps_idx : {}", associated_sps_id),
                }
                let mut vp =
                    VideoParameters::new(&ds.nalu_headers[i], cur_pps, &cur_subset_sps.sps);
                vp.mbaff_frame_flag = ds.slices[slice_idx].sh.mbaff_frame_flag;

                let res = insert_emulation_three_byte(&encode_slice_layer_extension_rbsp(
                    &ds.nalu_headers[i],
                    &ds.slices[slice_idx],
                    cur_subset_sps,
                    cur_pps,
                    &vp,
                    silent_mode,
                ));
                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(&res);

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }

                encoded_str.extend(res.clone());
                
                
               if rtp_out {
                    curr_nal.extend(res)
                }
                
                slice_idx += 1;
                //encoded_str.extend(insert_emulation_three_byte(ds.nalu_elements[i].content[1..]));
            }
            21 => {
                if !silent_mode {
                    println!("\t reencode_syntax_elements - NALU {} - Coded slice extension for a depth view component or a 3D-AVC texture view component", i);
                }
                // specified in Annex J
                // slice_layer_extension_rbsp();
                encoded_str.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                ));
                
                                
               if rtp_out {
                    curr_nal.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                    ));
                }
                
                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }
            }
            22..=23 => {
                if !silent_mode {
                    println!("\t reencode_syntax_elements - NALU {} - RESERVED nal_unit_type of {} - Copying Bytes", i, ds.nalu_headers[i].nal_unit_type);
                }
                encoded_str.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                ));
                
               if rtp_out {
                    curr_nal.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                    ));
                }
                
                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }
            }
            24..=31 => {
                if !silent_mode {
                    println!("\t reencode_syntax_elements - NALU {} - Unknown nal_unit_type of {} - Copying Bytes", i,  ds.nalu_headers[i].nal_unit_type);
                }
                // Ignore for now
                encoded_str.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                ));
                
               if rtp_out {
                    curr_nal.extend(insert_emulation_three_byte(
                    &ds.nalu_elements[i].content[1..],
                   ));
                }
                
                if avcc_out {
                    let mut cur_encoded_slice = encoded_header.clone();
                    cur_encoded_slice.extend(insert_emulation_three_byte(
                        &ds.nalu_elements[i].content[1..],
                    ));

                    avcc_encoding.nalus.push(cur_encoded_slice);
                }
            }
            _ => panic!(
                "\t reencode_syntax_elements - NALU {} - Unknown nal_unit_type of {}",
                i, ds.nalu_headers[i].nal_unit_type
            ),
        };

        // We do the skip at the end so that pps_idx or sps_idx, if that is the NALU that is skipped, can
        // still be used by other slices
        if i as i32 == cut_nalu {
            debug!(target: "encode","");
            debug!(target: "encode","Cutting NALU {}", cut_nalu);
            println!("Cutting above NALU {}", cut_nalu);
            continue;
        } else {
            // TODO: Cut avcc encodings as well
            encoded_video.extend(encoded_str)
        }
        
        if rtp_out { // fragment if too large
            if curr_nal.len() > FRAGMENT_SIZE {
        	println!("Fragmenting {} type {}", curr_nal.len(), ds.nalu_headers[i].nal_unit_type);
        	let nal = curr_nal;
        	let fua_chunks = nal.chunks(FRAGMENT_SIZE);
        	let mut j = 0;
        	let nal_type: u8 = ds.nalu_headers[i].nal_unit_type;
        	let num_chunks = fua_chunks.len();
        	for chunk in fua_chunks{
        	    let mut fua_bytes: Vec<u8> = Vec::new();
        	    let (forbidden, _overflow) = ds.nalu_headers[i].forbidden_zero_bit.overflowing_shl(7);
        	    let fu_indicator: u8 = 28 | forbidden | (ds.nalu_headers[i].nal_ref_idc << 5); // 28 is FU-A
        	    fua_bytes.push(fu_indicator);
        	    let mut fu_header = nal_type;
        	    if j == 0 {
        	    	fu_header = fu_header | 0x80; // S = 1
        	    	
        	    }
        	    if j == (num_chunks - 1) {
        	    	fu_header = fu_header | 0x40; // E = 1
        	    }
        	    fua_bytes.push(fu_header);
        	    fua_bytes.extend(chunk);
        	    rtp_nal.push(fua_bytes.clone());
        	    j = j + 1;

        	}
        	
        	
            }else{
               // println!("Adding {} type {} {:#04x}  {:#04x}  {:#04x}  {:#04x} ", curr_nal.len(), ds.nalu_headers[i].nal_unit_type, curr_nal[0], curr_nal[1], curr_nal[2], curr_nal[3]);
        	rtp_nal.push(curr_nal);
            }
        }
    }
     
    (encoded_video, avcc_encoding, rtp_nal)
}
